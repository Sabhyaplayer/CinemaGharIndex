<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CinemaGhar Index</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style type="text/css">
/* <![CDATA[ */
:root {
    --primary-color: #007bff;
    --primary-hover: #0056b3;
    --light-bg: #f8f9fa;
    --container-bg: #ffffff;
    --text-color: #343a40;
    --text-muted: #6c757d;
    --border-color: #dee2e6;
    --header-bg: #ffffff;
    --table-header-bg: #e9ecef;
    --table-row-hover: #f1f3f5;
    --error-color: #dc3545;
    --success-color: #28a745;
    --warning-bg: #fff3cd;
    --warning-text: #856404;
    --warning-border: #ffeeba;
    --pagination-active-bg: #007bff;
    --pagination-active-border: #007bff;
    --pagination-hover-bg: #e9ecef;
    --pagination-disabled-color: #adb5bd;
    --pagination-disabled-bg: #ffffff;
    --pagination-disabled-border: #dee2e6;
    --filter-active-border: #adb5bd;
    --tab-inactive-bg: #f1f3f5;
    --tab-active-bg: var(--container-bg);
    --tab-active-border: var(--primary-color);
    --tab-hover-bg: #e9ecef;

    --border-radius-sm: 0.25rem;
    --border-radius-md: 0.5rem;
    --border-radius-lg: 0.8rem;
    --shadow-sm: 0 1px 3px rgba(0,0,0,0.05);
    --shadow-md: 0 4px 10px rgba(0,0,0,0.08);
}

*, *::before, *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

html, body {
    width: 100%;
    height: 100%;
}

body {
     font-family: 'Poppins', Arial, sans-serif;
     background-color: var(--light-bg);
     color: var(--text-color);
     line-height: 1.6;
}
#cinemaghar-container {
    font-family: 'Poppins', Arial, sans-serif;
    padding: 15px;
    background-color: var(--container-bg);
    border-radius: var(--border-radius-lg);
    margin: 20px auto;
    max-width: 1200px;
    box-shadow: var(--shadow-md);
    position: relative;
    color: var(--text-color);
    overflow: hidden;
}

#cinemaghar-container header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 20px;
    margin-bottom: 25px; /* Adjusted margin */
    padding-bottom: 20px;
    border-bottom: 1px solid var(--border-color);
    flex-wrap: wrap;
    background-color: var(--header-bg);
    padding: 15px;
    border-radius: var(--border-radius-md) var(--border-radius-md) 0 0;
    margin: -15px -15px 25px -15px; /* Keep negative margin to align with container edges */
}
#cinemaghar-container header img {
    height: 60px;
    border-radius: var(--border-radius-md);
    flex-shrink: 0;
    box-shadow: var(--shadow-sm);
}
#cinemaghar-container .header-title-signature {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    min-width: 0;
}
#cinemaghar-container .header-title-signature h1 {
    font-size: 26px;
    font-weight: 600;
    margin: 0;
    color: var(--text-color);
    line-height: 1.2;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
#cinemaghar-container .header-title-signature .signature {
    font-size: 13px;
    color: var(--text-muted);
    margin: 4px 0 0 0;
    font-style: italic;
    font-weight: 300;
    padding-left: 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
#cinemaghar-container .header-buttons {
    display: flex;
    gap: 12px;
    align-items: center;
    flex-shrink: 0;
}
#cinemaghar-container .header-buttons .button svg {
    height: 1.1em;
    width: 1.1em;
    margin-right: 6px;
    vertical-align: text-bottom;
    fill: currentColor;
}

#cinemaghar-container h2 {
    font-size: 22px;
    color: var(--primary-color);
    font-weight: 600;
    margin-top: 0; /* Removed top margin as it's inside tab panel now */
    margin-bottom: 18px;
    padding-bottom: 8px;
    border-bottom: 2px solid var(--primary-color);
}

/* --- Global Filter/Search Area --- */
.filter-search-area {
    display: flex;
    gap: 15px;
    margin: 0 0 25px 0; /* Adjusted margins */
    align-items: center;
    flex-wrap: wrap;
    padding: 0; /* Removed padding if needed */
}

.search-group {
    display: flex;
    flex-grow: 1;
    min-width: 250px;
}

#cinemaghar-container #mainSearchInput { /* Use ID for the single search input */
    flex-grow: 1;
    padding: 12px 15px;
    border-radius: var(--border-radius-md);
    border: 1px solid var(--border-color);
    font-size: 16px;
    box-sizing: border-box;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
    height: 44px;
    outline: none;
}
#cinemaghar-container #mainSearchInput:focus { /* Use ID */
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
    z-index: 1;
    position: relative;
}

.filter-group {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-shrink: 0;
}

.filter-group label {
    font-size: 14px;
    font-weight: 500;
    color: var(--text-muted);
    white-space: nowrap;
}

#cinemaghar-container #mainQualityFilterSelect { /* Use ID for the single quality filter */
    padding: 10px 12px;
    border-radius: var(--border-radius-md);
    border: 1px solid var(--border-color);
    font-size: 14px;
    background-color: white;
    cursor: pointer;
    transition: border-color 0.2s ease, background-color 0.2s ease;
    min-width: 150px;
    height: 44px;
    line-height: 1.5;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="%236c757d" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>');
    background-repeat: no-repeat;
    background-position: right 10px center;
    background-size: 16px 12px;
    padding-right: 35px;
}
#cinemaghar-container #mainQualityFilterSelect:focus { /* Use ID */
    border-color: var(--primary-color);
    outline: none;
    box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
}
#cinemaghar-container #mainQualityFilterSelect.filter-active { /* Use ID */
    border-color: var(--filter-active-border);
    background-color: #eef;
    font-weight: 500;
}

/* --- Search Results Container (NEW) --- */
#searchResultsContainer {
    margin-top: 25px; /* Space below filter area */
}

/* --- Tab Navigation --- */
.tab-navigation {
    display: flex;
    margin-bottom: 20px;
    border-bottom: 1px solid var(--border-color);
    flex-wrap: wrap; /* Allow tabs to wrap on small screens */
}
.tab-button {
    padding: 10px 20px;
    cursor: pointer;
    background-color: var(--tab-inactive-bg);
    border: none;
    border-bottom: 3px solid transparent;
    font-size: 16px;
    font-weight: 500;
    color: var(--text-muted);
    transition: all 0.2s ease-in-out;
    margin-bottom: -1px; /* Overlap border-bottom */
    border-radius: var(--border-radius-sm) var(--border-radius-sm) 0 0;
    white-space: nowrap;
}
.tab-button:hover {
    background-color: var(--tab-hover-bg);
    color: var(--text-color);
}
.tab-button.active {
    background-color: var(--tab-active-bg);
    color: var(--primary-color);
    border-color: var(--border-color);
    border-bottom-color: var(--tab-active-border);
    font-weight: 600;
}

/* --- Tab Content --- */
.tab-content > div {
    display: none; /* Hide all panels by default */
    padding-top: 10px;
}
.tab-content > div.active {
    display: block; /* Show active panel */
}


#cinemaghar-container .table-container {
    overflow-x: auto;
    background: var(--container-bg);
    border-radius: var(--border-radius-lg);
    box-shadow: var(--shadow-md);
    margin-bottom: 10px;
    border: 1px solid var(--border-color);
}
/* Shared Table Styles (Apply to all tables including search results) */
#cinemaghar-container table {
    width: 100%;
    border-collapse: collapse;
    min-width: 700px;
}
#cinemaghar-container th, #cinemaghar-container td {
    padding: 13px 12px;
    border: none;
    border-bottom: 1px solid var(--border-color);
    text-align: left;
    font-size: 14px;
    vertical-align: middle;
    font-weight: 400;
}
#cinemaghar-container th.col-id, #cinemaghar-container td.col-id,
#cinemaghar-container th.col-size, #cinemaghar-container td.col-size,
#cinemaghar-container th.col-quality, #cinemaghar-container td.col-quality,
#cinemaghar-container th.col-updated, #cinemaghar-container td.col-updated,
#cinemaghar-container th.col-view, #cinemaghar-container td.col-view {
    text-align: center;
    white-space: nowrap;
}

#cinemaghar-container th {
    background-color: var(--table-header-bg);
    font-weight: 600;
    color: var(--text-color);
    white-space: nowrap;
    position: sticky;
    top: 0;
    z-index: 2;
    cursor: pointer;
    user-select: none;
}
/* Sorting Styles specific to tables with sorting */
#allFilesTable th.sortable:hover,
#moviesTable th.sortable:hover,
#seriesTable th.sortable:hover,
#searchResultsTable th.sortable:hover { /* Added search results table */
    background-color: #dde2e6;
}
#cinemaghar-container th .sort-indicator {
    display: inline-block;
    width: 0;
    height: 0;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    margin-left: 6px;
    vertical-align: middle;
    opacity: 0.5;
    transition: opacity 0.2s ease, border-color 0.2s;
}
#cinemaghar-container th.sort-asc .sort-indicator {
    border-bottom: 5px solid var(--primary-color);
    opacity: 1;
}
#cinemaghar-container th.sort-desc .sort-indicator {
    border-top: 5px solid var(--primary-color);
    opacity: 1;
}
#cinemaghar-container th:not(.sortable) .sort-indicator { display: none; }
#cinemaghar-container th:not(.sortable) { cursor: default; }

/* Column widths (Apply to all tables including search results) */
#cinemaghar-container th.col-id, #cinemaghar-container td.col-id { width: 6%; }
#cinemaghar-container th.col-filename, #cinemaghar-container td.col-filename { width: 45%; }
#cinemaghar-container th.col-size, #cinemaghar-container td.col-size { width: 12%; }
#cinemaghar-container th.col-quality, #cinemaghar-container td.col-quality { width: 12%; }
#cinemaghar-container th.col-updated, #cinemaghar-container td.col-updated { width: 15%; }
#cinemaghar-container th.col-view, #cinemaghar-container td.col-view { width: 10%; }

#cinemaghar-container tr:last-child td {
    border-bottom: none;
}
#cinemaghar-container tbody tr:not(.action-row):hover {
    background-color: var(--table-row-hover);
    cursor: default;
}

#cinemaghar-container td.col-filename {
    word-break: break-all;
    text-align: left;
    min-width: 150px;
    cursor: pointer;
    color: var(--primary-color);
    font-weight: 500;
    transition: color 0.2s ease;
    white-space: normal;
    position: relative;
}
#cinemaghar-container td.col-filename:hover {
    color: var(--primary-hover);
    text-decoration: underline;
}

#cinemaghar-container td.col-filename .quality-logo {
    height: 1.1em;
    width: auto;
    vertical-align: text-bottom;
    margin-left: 5px;
    display: inline-block;
    line-height: 1;
    filter: grayscale(30%);
    opacity: 0.8;
    transition: filter 0.2s ease, opacity 0.2s ease;
}
#cinemaghar-container td.col-filename:hover .quality-logo {
    filter: grayscale(0%);
    opacity: 1;
}

#cinemaghar-container td.col-quality {
    text-align: center;
    min-width: 80px;
    white-space: nowrap;
    font-weight: 500;
}
#cinemaghar-container td.col-updated {
    white-space: nowrap;
    min-width: 130px;
    color: var(--text-muted);
    font-size: 13px;
}
#cinemaghar-container td.status-message,
#cinemaghar-container td.error-message {
    color: var(--text-muted);
    font-style: italic;
    text-align: center;
    padding: 20px;
    font-size: 15px;
}
#cinemaghar-container td.error-message {
    color: var(--error-color);
    font-weight: 500;
}

/* Action Row */
#cinemaghar-container tr.action-row {
    display: none;
    background-color: #f0f2f5;
}
#cinemaghar-container .action-row td {
    padding: 20px 15px;
    text-align: left;
    border-bottom: none;
    box-shadow: inset 0 3px 5px rgba(0,0,0,0.04);
}
#cinemaghar-container .action-info {
    margin-bottom: 20px;
    font-size: 14px;
    color: var(--text-muted);
    text-align: left;
    line-height: 1.7;
}
#cinemaghar-container .action-info .info-item {
    display: block;
    margin-bottom: 8px;
}
#cinemaghar-container .action-info strong {
    color: var(--text-color);
    font-weight: 600;
    margin-right: 8px;
    display: inline-block;
    min-width: 80px;
}
#cinemaghar-container .action-info .quality-logo {
    height: 1.1em;
    width: auto;
    vertical-align: text-bottom;
    margin-left: 4px;
    display: inline-block;
}

#cinemaghar-container .action-buttons-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: flex-start;
    gap: 10px;
    margin-bottom: 15px;
    border-top: 1px solid var(--border-color);
    padding-top: 20px;
}

/* Buttons */
#cinemaghar-container .button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 9px 16px;
    margin: 2px 0;
    background-color: var(--success-color); /* Default */
    color: white !important;
    border: none;
    border-radius: var(--border-radius-md);
    text-decoration: none;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    text-align: center;
    white-space: nowrap;
    line-height: 1.4;
    transition: all 0.2s ease-in-out;
    box-shadow: var(--shadow-sm);
}
#cinemaghar-container .button:hover {
    opacity: 1;
    filter: brightness(1.1);
    box-shadow: 0 3px 6px rgba(0,0,0,0.1);
    transform: translateY(-1px);
}
#cinemaghar-container .button:active {
    filter: brightness(0.95);
    transform: translateY(0);
    box-shadow: var(--shadow-sm);
}

/* Specific Button Colors */
#cinemaghar-container .view-button { background-color: #6c757d; }
#cinemaghar-container .view-button:hover { background-color: #5a6268; }
#cinemaghar-container .play-button { background-color: var(--success-color); }
#cinemaghar-container .intent-button { background-color: #17a2b8; }
#cinemaghar-container .vlc-button { background-color: #fd7e14; }
#cinemaghar-container .download-button { background-color: var(--primary-color); }
#cinemaghar-container .telegram-button { background-color: #0088cc; }
#cinemaghar-container .gdflix-button { background-color: #E50914; }
#cinemaghar-container .hubcloud-button { background-color: #1E90FF; }
#cinemaghar-container .filepress-button { background-color: #6c757d; }
#cinemaghar-container .gdtot-button { background-color: #ffc107; color: #333 !important; }


/* Copy Feedback */
#cinemaghar-container .copy-feedback {
    display: inline-block;
    margin-left: 10px;
    font-size: 13px;
    color: var(--success-color);
    font-weight: 600;
    opacity: 0;
    transition: opacity 0.3s ease;
    vertical-align: middle;
}
#cinemaghar-container .copy-feedback.show {
    opacity: 1;
}

/* Video Player Container - Initially Hidden */
#cinemaghar-container .video-container {
    /* display: none;  Set by JS now, but initial CSS makes it explicit */
    margin: 20px auto 0 auto;
    background: #f1f3f5;
    padding: 50px 20px 20px 20px;
    border-radius: var(--border-radius-lg);
    box-shadow: 0 5px 15px rgba(0,0,0,0.15);
    position: relative;
    box-sizing: border-box;
    width: 100%;
    max-width: 850px;
    text-align: center;
    /* display: flex; /* Set by JS when shown */
    flex-direction: column;
}
#cinemaghar-container .close-btn {
    position: absolute;
    top: 15px;
    right: 18px;
    background: var(--error-color);
    color: white !important;
    border: none;
    padding: 6px 12px;
    border-radius: var(--border-radius-md);
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    z-index: 10;
    transition: background-color 0.2s ease;
}
#cinemaghar-container .close-btn:hover {
    background-color: #c82333;
}
#cinemaghar-container #audioWarning {
    display: none; /* Managed by JS */
    background-color: var(--warning-bg);
    color: var(--warning-text);
    border: 1px solid var(--warning-border);
    padding: 12px;
    margin-bottom: 15px;
    border-radius: var(--border-radius-md);
    font-size: 14px;
    text-align: center;
    position: relative;
    z-index: 1;
    line-height: 1.5;
    flex-shrink: 0;
}
#cinemaghar-container #audioWarning strong { font-weight: 600; }
#cinemaghar-container #html5VideoPlayer {
    width: 100%;
    max-height: 480px;
    display: block;
    margin: 10px auto 15px auto;
    background: black;
    border-radius: var(--border-radius-md);
    outline: none;
    box-shadow: var(--shadow-md);
    flex-shrink: 1;
    flex-grow: 1;
    object-fit: contain;
    cursor: default;
}
#cinemaghar-container .custom-controls {
    margin-top: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
    flex-shrink: 0;
    position: relative;
}
/* Style custom control buttons */
#cinemaghar-container .custom-controls .button {
    background-color: #5a6268;
    min-width: 60px;
    font-size: 12px;
    padding: 6px 10px;
    color: white !important;
}
#cinemaghar-container .custom-controls .button:hover {
    background-color: #495057;
}
#cinemaghar-container #audioTrackSelect {
    padding: 6px 10px;
    border-radius: var(--border-radius-md);
    background-color: #e9ecef;
    border: 1px solid var(--border-color);
    font-size: 13px;
    font-family: inherit;
    cursor: pointer;
    max-width: 150px;
    display: none; /* Managed by JS */
    transition: border-color 0.2s ease;
    height: 30px;
    line-height: 1;
    vertical-align: middle;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="%236c757d" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>');
    background-repeat: no-repeat;
    background-position: right 5px center;
    background-size: 12px 10px;
    padding-right: 25px;
}
#cinemaghar-container #audioTrackSelect:focus {
    border-color: var(--primary-color);
    outline: none;
}
#cinemaghar-container #videoTitle {
    font-weight: 600;
    margin-bottom: 15px;
    font-size: 18px;
    color: var(--text-color);
    position: relative;
    z-index: 1;
    padding-top: 0;
    text-align: left;
    word-break: break-word;
    flex-shrink: 0;
}
#cinemaghar-container .vlc-copy-box {
    margin-top: 20px;
    background: #e9ecef;
    padding: 12px 15px;
    border-radius: var(--border-radius-md);
    font-size: 14px;
    word-wrap: break-word;
    line-height: 1.6;
    color: var(--text-muted);
    text-align: left;
    border: 1px solid var(--border-color);
    flex-shrink: 0;
    display: none; /* Managed by JS */
}
#cinemaghar-container .vlc-copy-box strong {
    color: var(--text-color);
    font-weight: 600;
    display: block;
    margin-bottom: 5px;
}
#cinemaghar-container .vlc-copy-box code {
    background: #dcdcdc;
    padding: 3px 6px;
    border-radius: var(--border-radius-sm);
    font-family: 'Courier New', Courier, monospace;
    word-break: break-all;
    color: #333;
    font-size: 13px;
    display: block;
    margin-top: 3px;
    user-select: all;
}

/* Player Controls Grouping */
.player-control-group {
    display: flex;
    align-items: center;
    gap: 6px;
}
.player-control-group label {
    font-size: 12px;
    color: var(--text-muted);
    white-space: nowrap;
}
#volumeSlider {
    width: 80px;
    cursor: pointer;
    height: 5px;
    transition: opacity 0.2s ease;
    vertical-align: middle;
    accent-color: var(--primary-color);
}
#playbackSpeedSelect {
    padding: 4px 8px;
    font-size: 12px;
    border-radius: var(--border-radius-sm);
    border: 1px solid var(--border-color);
    background-color: #fff;
    height: 30px;
    line-height: 1;
    vertical-align: middle;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="%236c757d" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>');
    background-repeat: no-repeat;
    background-position: right 5px center;
    background-size: 12px 10px;
    padding-right: 25px;
}

/* --- Fullscreen Specific Styles --- */
#cinemaghar-container .video-container.is-fullscreen {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    max-width: none;
    padding: 0;
    margin: 0;
    border-radius: 0;
    background-color: black;
    z-index: 2147483647;
    display: flex;
    flex-direction: column;
    justify-content: center;
}

#cinemaghar-container .video-container.is-fullscreen #html5VideoPlayer {
    width: 100%;
    height: 100%;
    max-height: none;
    flex-grow: 1;
    flex-shrink: 1;
    border-radius: 0;
    box-shadow: none;
    margin: 0;
    object-fit: contain;
    cursor: default;
}

/* --- HIDE CONTROLS IN FULLSCREEN --- */
#cinemaghar-container .video-container.is-fullscreen .custom-controls {
    display: none !important;
}
#cinemaghar-container .video-container.is-fullscreen .close-btn {
    display: none !important;
}

#cinemaghar-container .video-container.is-fullscreen #videoTitle,
#cinemaghar-container .video-container.is-fullscreen #audioWarning,
#cinemaghar-container .video-container.is-fullscreen .vlc-copy-box {
    display: none !important;
}
/* --- End Fullscreen Specific Styles --- */

/* Pagination */
.pagination-container {
    text-align: center;
    margin: 25px 0 10px 0;
    user-select: none;
}
.pagination-container button,
.pagination-container span {
    display: inline-block;
    padding: 8px 14px;
    margin: 0 3px;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius-md);
    background-color: white;
    color: var(--primary-color);
    cursor: pointer;
    font-size: 14px;
    transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    vertical-align: middle;
}
.pagination-container button:hover:not(:disabled) {
    background-color: var(--pagination-hover-bg);
    border-color: #adb5bd;
}
.pagination-container span.current-page {
    background-color: var(--pagination-active-bg);
    border-color: var(--pagination-active-border);
    color: white;
    font-weight: 600;
    cursor: default;
}
.pagination-container button:disabled {
    color: var(--pagination-disabled-color);
    background-color: var(--pagination-disabled-bg);
    border-color: var(--pagination-disabled-border);
    cursor: not-allowed;
    opacity: 0.7;
}
.pagination-container .page-info {
    font-size: 13px;
    color: var(--text-muted);
    margin: 0 5px;
    padding: 8px 0;
    border: none;
    background: none;
    cursor: default;
    display: inline-block;
    vertical-align: middle;
}

/* Spinner */
.spinner {
    border: 4px solid rgba(0, 0, 0, 0.1);
    width: 36px;
    height: 36px;
    border-radius: 50%;
    border-left-color: var(--primary-color);
    margin: 30px auto;
    animation: spin 1s ease infinite;
}
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Responsive Styles */
@media screen and (max-width: 768px) {
  body { font-size: 14px; }
  #cinemaghar-container { padding: 10px; margin: 10px; }

  #cinemaghar-container header {
      padding: 12px 10px;
      margin: -10px -10px 20px -10px;
      gap: 10px;
      flex-direction: column;
      align-items: flex-start;
  }
  #cinemaghar-container header img { height: 45px; }
  #cinemaghar-container .header-title-signature h1 { font-size: 20px; }
  #cinemaghar-container .header-title-signature .signature { font-size: 12px; }
  #cinemaghar-container .header-buttons {
      gap: 8px;
      width: 100%;
      justify-content: flex-start;
      flex-wrap: wrap;
  }
  #cinemaghar-container .header-buttons .button {
      font-size: 12px;
      padding: 8px 12px;
   }
  #cinemaghar-container .header-buttons .button svg { height: 1em; width: 1em; margin-right: 5px;}

  /* Global Filter/Search Area on mobile */
  .filter-search-area {
      flex-direction: column;
      align-items: stretch;
      gap: 12px;
      margin: 0 0 20px 0; /* Adjusted margins */
  }
  .search-group {
      min-width: unset;
  }
  #cinemaghar-container #mainSearchInput { /* Use ID */
      min-width: unset;
      width: 100%;
      font-size: 15px;
      padding: 11px 13px;
      height: 40px;
      border-radius: var(--border-radius-md);
  }

  .filter-group {
      justify-content: space-between;
      gap: 10px;
  }
  .filter-group label { font-size: 13px; margin-right: 5px;}
  #cinemaghar-container #mainQualityFilterSelect { /* Use ID */
      font-size: 14px;
      padding: 9px 10px;
      min-width: unset;
      flex-grow: 1;
      width: auto;
      height: 40px;
      padding-right: 30px;
      background-position: right 8px center;
  }

  /* Search Results container mobile adjustments */
  #searchResultsContainer { margin-top: 20px; }

  .tab-navigation { margin-bottom: 15px; }
  .tab-button { padding: 8px 12px; font-size: 14px; } /* Reduced padding slightly */

  #cinemaghar-container .table-container {
      border: none;
      box-shadow: none;
      border-radius: 0;
      margin-left: -10px;
      margin-right: -10px;
      overflow-x: visible;
   }
   /* Apply table adjustments to ALL tables, including search results */
   #cinemaghar-container table {
        min-width: unset;
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius-md);
        box-shadow: var(--shadow-sm);
        display: block;
        overflow-x: auto;
        white-space: nowrap;
        -webkit-overflow-scrolling: touch;
   }
   #cinemaghar-container thead, #cinemaghar-container tbody, #cinemaghar-container tr {
        display: table;
        width: 100%;
        table-layout: fixed;
   }
   #cinemaghar-container thead {
        position: sticky;
        top: 0;
        z-index: 3;
   }

  #cinemaghar-container th, #cinemaghar-container td {
      padding: 10px 8px;
      font-size: 13px;
      border-bottom: 1px solid var(--border-color);
      display: table-cell;
      white-space: normal;
      vertical-align: middle;
  }

  /* Hide columns on mobile (Applies to ALL tables now) */
  #cinemaghar-container thead tr th.col-size,
  #cinemaghar-container thead tr th.col-updated,
  #cinemaghar-container tbody tr:not(.action-row) td.col-size,
  #cinemaghar-container tbody tr:not(.action-row) td.col-updated {
       display: none;
  }

   /* Adjust visible column widths (Applies to ALL tables now) */
   #cinemaghar-container th.col-id, #cinemaghar-container td.col-id { width: 12%; text-align: center; }
   #cinemaghar-container th.col-filename, #cinemaghar-container td.col-filename { width: 48%; font-weight: 500; }
   #cinemaghar-container th.col-quality, #cinemaghar-container td.col-quality { width: 20%; text-align: center; font-weight: 500;}
   #cinemaghar-container th.col-view, #cinemaghar-container td.col-view { width: 20%; text-align: center; }

  #cinemaghar-container th .sort-indicator { margin-left: 4px; border-width: 4px; }
  #cinemaghar-container th.sort-asc .sort-indicator { border-bottom-width: 4px; }
  #cinemaghar-container th.sort-desc .sort-indicator { border-top-width: 4px; }

  #cinemaghar-container td.col-filename {
      word-break: break-word;
      white-space: normal;
      cursor: pointer;
  }
  #cinemaghar-container td.col-filename .quality-logo {
       height: 0.9em;
       margin-left: 3px;
       vertical-align: baseline;
  }
  #cinemaghar-container td.col-quality { min-width: unset; }

   #cinemaghar-container td.col-view .button.view-button {
      font-size: 12px;
      padding: 6px 8px;
      width: 100%;
      min-width: 45px;
      box-sizing: border-box;
   }

   #cinemaghar-container .action-row td {
        padding: 15px 10px;
        display: block;
        width: auto;
        white-space: normal;
   }

  #cinemaghar-container .action-info {
      font-size: 13px;
      margin-bottom: 15px;
  }
   #cinemaghar-container .action-info .info-item {
        display: block;
        margin-bottom: 6px;
        line-height: 1.5;
   }
   #cinemaghar-container .action-info strong {
        display: inline-block;
        min-width: 65px;
        font-weight: 600;
        margin-right: 5px;
   }
   #cinemaghar-container .action-info .quality-logo {
        height: 0.9em;
        vertical-align: baseline;
   }

  #cinemaghar-container .action-buttons-container {
      flex-direction: column;
      align-items: stretch;
      gap: 8px;
      padding-top: 15px;
  }
  #cinemaghar-container .action-buttons-container .button {
      font-size: 13px;
      padding: 10px 15px;
      width: 100%;
      max-width: none;
      margin: 0;
      box-sizing: border-box;
  }

  #cinemaghar-container #html5VideoPlayer { max-height: 280px; }
  #cinemaghar-container .video-container {
      padding: 45px 10px 15px 10px;
      max-width: 100%;
      margin-left: 0;
      margin-right: 0;
      border-radius: var(--border-radius-md);
  }
  #cinemaghar-container .video-container.is-fullscreen #html5VideoPlayer {
      max-height: none;
  }
  #cinemaghar-container .close-btn { top: 12px; right: 12px; padding: 5px 9px; font-size: 12px; }
  #cinemaghar-container #videoTitle { font-size: 16px; }
  #cinemaghar-container #audioWarning { font-size: 12px; padding: 10px; line-height: 1.4; }
  #cinemaghar-container .custom-controls { gap: 8px; }
  #cinemaghar-container .custom-controls .button { padding: 7px 10px; font-size: 11px; min-width: 55px;}
  #cinemaghar-container #audioTrackSelect { font-size: 12px; padding: 5px 8px; max-width: 120px; height: 34px; }
  #cinemaghar-container .vlc-copy-box { font-size: 12px; padding: 10px; }
  #cinemaghar-container .vlc-copy-box code { font-size: 11px; }
  .player-control-group label { font-size: 11px;}
  #volumeSlider { width: 60px;}
  #playbackSpeedSelect { font-size: 12px; padding: 3px 6px; height: 34px; }

    .pagination-container { margin: 20px 0 5px 0; }
    .pagination-container button,
    .pagination-container span { padding: 7px 11px; font-size: 13px; margin: 0 2px;}
    .pagination-container .page-info { font-size: 12px; margin: 0 5px; padding: 7px 0;}
}
/* ]]> */
</style>
</head>
<body>
<div id="cinemaghar-container">
  <header>
    <img src="https://i.ibb.co/s1Kn4MT/c68903b0d838.jpg" alt="CinemaGhar Logo" />
    <div class="header-title-signature">
        <h1>CinemaGhar Index</h1>
        <p class="signature">Curated with ❣️ by The_SabhyaPlayer</p>
    </div>
    <div class="header-buttons">
        <a href="https://t.me/The_Sabhyaplayer_bot" target="_blank" rel="noopener noreferrer" class="button telegram-button">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" aria-hidden="true" focusable="false" style="width:1.1em; height:1.1em; fill:currentColor; margin-right:6px; vertical-align:text-bottom;">
                <path d="M97.9,161.4l-2.8,29.9c3.4,0,4.9-1.7,6.8-3.6l14.1-13.6l29.4,21.7c5.4,3.1,9.3,1.5,10.8-4.9l19.9-93.5c1.8-7.8-2.4-11.5-7.5-9.3L36.4,127.1c-7.6,3-7.6,7.5-1.3,9.6l30.2,9.4l70.4-44.3c3.3-2,6.1-0.9,3.6,1.4L97.9,161.4z"/>
            </svg>
            <span>Contact The_SabhyaPlayer</span>
        </a>
        <a href="https://t.me/Cinemaghar_Lobby" target="_blank" rel="noopener noreferrer" class="button telegram-button">
             <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" aria-hidden="true" focusable="false" style="width:1.1em; height:1.1em; fill:currentColor; margin-right:6px; vertical-align:text-bottom;">
                 <path d="M97.9,161.4l-2.8,29.9c3.4,0,4.9-1.7,6.8-3.6l14.1-13.6l29.4,21.7c5.4,3.1,9.3,1.5,10.8-4.9l19.9-93.5c1.8-7.8-2.4-11.5-7.5-9.3L36.4,127.1c-7.6,3-7.6,7.5-1.3,9.6l30.2,9.4l70.4-44.3c3.3-2,6.1-0.9,3.6,1.4L97.9,161.4z"/>
             </svg>
            <span>Join Channel</span>
        </a>
    </div>
  </header>

  <!-- Global Filter/Search Area -->
  <div class="filter-search-area">
      <div class="search-group">
          <input type="search" id="mainSearchInput" placeholder="Search all files by name or ID..." />
      </div>
      <div class="filter-group">
          <label for="mainQualityFilterSelect">Quality:</label>
          <select id="mainQualityFilterSelect">
              <option value="">All Qualities</option>
              <!-- Options populated by JS -->
          </select>
      </div>
  </div>

  <!-- Search Results Container (NEW) - Initially Hidden -->
  <div id="searchResultsContainer" style="display: none;">
      <h2>Search Results</h2>
      <div class="table-container">
          <table id="searchResultsTable">
              <thead>
                  <tr>
                      <th class="sortable col-id" data-sort-key="id">#<span class="sort-indicator"></span></th>
                      <th class="sortable col-filename" data-sort-key="filename">Filename<span class="sort-indicator"></span></th>
                      <th class="sortable col-size" data-sort-key="size">Size<span class="sort-indicator"></span></th>
                      <th class="sortable col-quality" data-sort-key="quality">Quality<span class="sort-indicator"></span></th>
                      <th class="sortable col-updated" data-sort-key="lastUpdated">Updated<span class="sort-indicator"></span></th>
                      <th class="col-view">View</th>
                  </tr>
              </thead>
              <tbody id="searchResultsTableBody">
                 <!-- Content generated by JS -->
              </tbody>
          </table>
      </div>
      <div class="pagination-container" id="searchResultsPaginationControls" style="display: none;">
          <!-- Content generated by JS -->
      </div>
  </div>

  <!-- Tab Navigation (Will be hidden during search) -->
  <div class="tab-navigation">
      <button class="tab-button active" id="updatesTabButton" onclick="switchTab('updates')">Updates (24h)</button>
      <button class="tab-button" id="allFilesTabButton" onclick="switchTab('allFiles')">All Files</button>
      <button class="tab-button" id="moviesTabButton" onclick="switchTab('movies')">Movies</button>
      <button class="tab-button" id="seriesTabButton" onclick="switchTab('series')">Series</button>
  </div>

  <!-- Tab Content Area (Will be hidden during search) -->
  <div class="tab-content">
      <!-- Updates Panel -->
      <div id="updatesTabPanel" class="active">
          <h2>Updates (Last 24 Hours)</h2>
          <div class="table-container">
              <table id="updatesTable">
                  <thead>
                      <tr>
                          <th class="col-id">#</th>
                          <th class="col-filename">Filename</th>
                          <th class="col-size">Size</th>
                          <th class="col-quality">Quality</th>
                          <th class="col-updated">Updated</th>
                          <th class="col-view">View</th>
                       </tr>
                   </thead>
                  <tbody id="updatesTableBody">
                      <!-- Content generated by JS -->
                  </tbody>
              </table>
          </div>
          <!-- No Pagination for Updates -->
      </div>

      <!-- All Files Panel -->
      <div id="allFilesTabPanel">
          <h2>All Files</h2>
          <div class="table-container">
              <table id="allFilesTable">
                  <thead>
                      <tr>
                          <th class="sortable col-id" data-sort-key="id">#<span class="sort-indicator"></span></th>
                          <th class="sortable col-filename" data-sort-key="filename">Filename<span class="sort-indicator"></span></th>
                          <th class="sortable col-size" data-sort-key="size">Size<span class="sort-indicator"></span></th>
                          <th class="sortable col-quality" data-sort-key="quality">Quality<span class="sort-indicator"></span></th>
                          <th class="sortable col-updated" data-sort-key="lastUpdated">Updated<span class="sort-indicator"></span></th>
                          <th class="col-view">View</th>
                      </tr>
                  </thead>
                  <tbody id="allFilesTableBody">
                     <!-- Content generated by JS -->
                  </tbody>
              </table>
          </div>
          <div class="pagination-container" id="allFilesPaginationControls" style="display: none;">
              <!-- Content generated by JS -->
          </div>
      </div>

       <!-- Movies Panel -->
      <div id="moviesTabPanel">
          <h2>Movies</h2>
          <div class="table-container">
              <table id="moviesTable">
                  <thead>
                      <tr>
                          <th class="sortable col-id" data-sort-key="id">#<span class="sort-indicator"></span></th>
                          <th class="sortable col-filename" data-sort-key="filename">Filename<span class="sort-indicator"></span></th>
                          <th class="sortable col-size" data-sort-key="size">Size<span class="sort-indicator"></span></th>
                          <th class="sortable col-quality" data-sort-key="quality">Quality<span class="sort-indicator"></span></th>
                          <th class="sortable col-updated" data-sort-key="lastUpdated">Updated<span class="sort-indicator"></span></th>
                          <th class="col-view">View</th>
                      </tr>
                  </thead>
                  <tbody id="moviesTableBody">
                     <!-- Content generated by JS -->
                  </tbody>
              </table>
          </div>
          <div class="pagination-container" id="moviesPaginationControls" style="display: none;">
              <!-- Content generated by JS -->
          </div>
      </div>

       <!-- Series Panel -->
      <div id="seriesTabPanel">
          <h2>Series</h2>
          <div class="table-container">
              <table id="seriesTable">
                   <thead>
                      <tr>
                          <th class="sortable col-id" data-sort-key="id">#<span class="sort-indicator"></span></th>
                          <th class="sortable col-filename" data-sort-key="filename">Filename<span class="sort-indicator"></span></th>
                          <th class="sortable col-size" data-sort-key="size">Size<span class="sort-indicator"></span></th>
                          <th class="sortable col-quality" data-sort-key="quality">Quality<span class="sort-indicator"></span></th>
                          <th class="sortable col-updated" data-sort-key="lastUpdated">Updated<span class="sort-indicator"></span></th>
                          <th class="col-view">View</th>
                      </tr>
                  </thead>
                  <tbody id="seriesTableBody">
                     <!-- Content generated by JS -->
                  </tbody>
              </table>
          </div>
          <div class="pagination-container" id="seriesPaginationControls" style="display: none;">
              <!-- Content generated by JS -->
          </div>
      </div>

  </div> <!-- End .tab-content -->

  <!-- Video Player Container - Moved here, outside tabs/search results, initially hidden -->
  <div class="video-container" id="videoContainer" style="display: none;">
      <button class="close-btn" onclick="closePlayer()">✖ Close</button>
      <div id="audioWarning" style="display: none;"></div>
      <div id="videoTitle"></div>
      <video id="html5VideoPlayer" controls autoplay controlsList="nodownload noremoteplayback">
          Your browser does not support the video tag.
      </video>
      <div class="custom-controls" id="customControlsContainer">
          <button class="button" onclick="seekVideo(-10)">« 10s</button>
          <button class="button" onclick="seekVideo(10)">10s »</button>
          <button class="button" id="muteButton" onclick="toggleMute()">Mute</button>
          <div class="player-control-group">
              <label for="volumeSlider">Vol:</label>
              <input type="range" id="volumeSlider" min="0" max="1" step="0.05" value="1" oninput="setVolume(this.value)" onchange="setVolume(this.value)">
          </div>
          <select id="audioTrackSelect" onchange="changeAudioTrack(this)" title="Select Audio Track" style="display: none;"></select>
          <div class="player-control-group">
             <label for="playbackSpeedSelect">Speed:</label>
             <select id="playbackSpeedSelect" onchange="setPlaybackSpeed(this.value)">
                <option value="0.5">0.5x</option>
                <option value="0.75">0.75x</option>
                <option value="1" selected>1x</option>
                <option value="1.25">1.25x</option>
                <option value="1.5">1.5x</option>
                <option value="2">2x</option>
             </select>
          </div>
          <button class="button" onclick="toggleFullscreen()">Fullscreen</button>
      </div>
      <div class="vlc-copy-box" id="vlcBox" style="display:none;">
          <strong>External Player URL:</strong>
          <code id="vlcText"></code>
          <span class="copy-feedback" id="copyFeedback">Copied!</span>
      </div>
  </div>
</div> <!-- End #cinemaghar-container -->

<script type="text/javascript">
// <![CDATA[

const config = {
    GSheetWebAppURL: "https://script.google.com/macros/s/AKfycbzcV_vEcrlZYVYnw-RFQOsHtzfdIIEwh4Vfp2tPp2wR1I8by2TDTGyQZH9i2Gy-0WMoAw/exec",
    HDR_LOGO_URL: "https://as1.ftcdn.net/v2/jpg/05/32/83/72/1000_F_532837228_v8CGZRU0jy39uCtqFRnJz6xDntrGuLLx.webp",
    FOURK_LOGO_URL: "https://i.pinimg.com/736x/85/c4/b0/85c4b0a2fb8612825d0cd2f53460925f.jpg",
    ITEMS_PER_PAGE: 50,
    LOCAL_STORAGE_KEY: 'cinemaGharState_v5', // Incremented version
    PLAYER_VOLUME_KEY: 'cinemaGharPlayerVolume',
    PLAYER_SPEED_KEY: 'cinemaGharPlayerSpeed',
    SEARCH_DEBOUNCE_DELAY: 350
};

let allMovieData = [];
let filteredAndSortedData = [];
let uniqueQualities = new Set();
let activeActionRow = null;
let copyTimeout;
let searchDebounceTimeout;
let currentActiveTab = 'updates'; // Default starting tab
let isSearchActive = false; // Flag to track search mode

// --- State Management ---
let currentState = {
    searchTerm: '',
    qualityFilter: '',
    sortColumn: 'lastUpdated',
    sortDirection: 'desc',
    currentPage: 1, // Current page for the *active view* (tab or search)
    savedPageAll: 1,
    savedPageMovies: 1,
    savedPageSeries: 1,
    savedTabBeforeSearch: 'updates' // Remember which tab was active before searching
};

// --- DOM Element References ---
const container = document.getElementById('cinemaghar-container');
const videoContainer = document.getElementById('videoContainer');
const videoElement = document.getElementById('html5VideoPlayer');
const videoTitle = document.getElementById('videoTitle');
const vlcBox = document.getElementById('vlcBox');
const vlcText = document.getElementById('vlcText');
const audioWarningDiv = document.getElementById('audioWarning');
const muteButton = document.getElementById('muteButton');
const volumeSlider = document.getElementById('volumeSlider');
const playbackSpeedSelect = document.getElementById('playbackSpeedSelect');
const customControlsContainer = document.getElementById('customControlsContainer');
const audioTrackSelect = document.getElementById('audioTrackSelect');
const copyFeedbackSpan = document.getElementById('copyFeedback');
const playerCloseButton = document.querySelector('.video-container .close-btn');

const searchInput = document.getElementById('mainSearchInput');
const qualityFilterSelect = document.getElementById('mainQualityFilterSelect');

// NEW: Search Results Area
const searchResultsContainer = document.getElementById('searchResultsContainer');
const searchResultsTableBody = document.getElementById('searchResultsTableBody');
const searchResultsTableHead = document.querySelector('#searchResultsTable thead'); // For sorting
const searchResultsPaginationControls = document.getElementById('searchResultsPaginationControls');

// Tab Navigation and Content Area
const tabNavigation = document.querySelector('.tab-navigation');
const tabContent = document.querySelector('.tab-content');

// Tab Buttons
const updatesTabButton = document.getElementById('updatesTabButton');
const allFilesTabButton = document.getElementById('allFilesTabButton');
const moviesTabButton = document.getElementById('moviesTabButton');
const seriesTabButton = document.getElementById('seriesTabButton');

// Tab Panels
const updatesTabPanel = document.getElementById('updatesTabPanel');
const allFilesTabPanel = document.getElementById('allFilesTabPanel');
const moviesTabPanel = document.getElementById('moviesTabPanel');
const seriesTabPanel = document.getElementById('seriesTabPanel');

// Table Bodies (Tabs)
const updatesTableBody = document.getElementById('updatesTableBody');
const allFilesTableBody = document.getElementById('allFilesTableBody');
const moviesTableBody = document.getElementById('moviesTableBody');
const seriesTableBody = document.getElementById('seriesTableBody');

// Table Headers (Tabs)
const allFilesTableHead = document.querySelector('#allFilesTable thead');
const moviesTableHead = document.querySelector('#moviesTable thead');
const seriesTableHead = document.querySelector('#seriesTable thead');

// Pagination Containers (Tabs)
const allFilesPaginationControls = document.getElementById('allFilesPaginationControls');
const moviesPaginationControls = document.getElementById('moviesPaginationControls');
const seriesPaginationControls = document.getElementById('seriesPaginationControls');

// Mappings for easier tab handling
const tabMappings = {
    updates: { button: updatesTabButton, panel: updatesTabPanel, pagination: null, savedPageKey: null },
    allFiles: { button: allFilesTabButton, panel: allFilesTabPanel, pagination: allFilesPaginationControls, savedPageKey: 'savedPageAll' },
    movies: { button: moviesTabButton, panel: moviesTabPanel, pagination: moviesPaginationControls, savedPageKey: 'savedPageMovies' },
    series: { button: seriesTabButton, panel: seriesTabPanel, pagination: seriesPaginationControls, savedPageKey: 'savedPageSeries' }
};

// --- Utility Functions (sanitize, TimeAgo, extractSizeData, getMimeTypeFromUrl, handleVideoError, extractQualityFromFilename, normalizeTextForSearch) ---
// ... (Keep these exactly the same as in your original code) ...
const sanitize = (str) => { if (str === null || typeof str === 'undefined') return ""; const temp = document.createElement('div'); temp.textContent = String(str); return temp.innerHTML; };
const TimeAgo = { MINUTE: 60, HOUR: 3600, DAY: 86400, WEEK: 604800, MONTH: 2592000, YEAR: 31536000, format: (isoString) => { if (!isoString) return 'N/A'; try { const date = new Date(isoString); const seconds = Math.floor((new Date() - date) / 1000); if (isNaN(seconds) || seconds < 0) { return TimeAgo.formatFullDate(date); } if (seconds < 2) return "just now"; if (seconds < TimeAgo.MINUTE) return `${seconds} sec${seconds > 1 ? 's' : ''} ago`; if (seconds < TimeAgo.HOUR) return `${Math.floor(seconds / TimeAgo.MINUTE)} min${Math.floor(seconds / TimeAgo.MINUTE) > 1 ? 's' : ''} ago`; if (seconds < TimeAgo.DAY) return `${Math.floor(seconds / TimeAgo.HOUR)} hr${Math.floor(seconds / TimeAgo.HOUR) > 1 ? 's' : ''} ago`; if (seconds < TimeAgo.DAY * 2) return "Yesterday"; if (seconds < TimeAgo.WEEK) return `${Math.floor(seconds / TimeAgo.DAY)} days ago`; return TimeAgo.formatFullDate(date, true); } catch (e) { console.error("Date Format Error (TimeAgo):", isoString, e); return 'Invalid Date'; } }, formatFullDate: (date, short = false) => { if (!(date instanceof Date) || isNaN(date.getTime())) return 'Invalid Date'; const optsDate = short ? { year: '2-digit', month: 'numeric', day: 'numeric' } : { year: 'numeric', month: 'short', day: 'numeric' }; const optsTime = { hour: 'numeric', minute: '2-digit', hour12: true }; try { return `${date.toLocaleDateString(undefined, optsDate)}${short ? '' : ', ' + date.toLocaleTimeString(undefined, optsTime)}`; } catch (e) { console.error("toLocaleDateString/Time failed:", e); return `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')}`; } } };
function extractSizeData(inputString) { if (!inputString) return { value: 0, unit: '', display: 'N/A', bytes: 0 }; const r = /(?<size>[\d.]+)\s?(?<unit>GB|MB)/i; const m = String(inputString).match(r); if (m?.groups?.size && m?.groups?.unit) { const value = parseFloat(m.groups.size); const unit = m.groups.unit.toUpperCase(); if (!isNaN(value)) { const bytes = unit === 'GB' ? value * 1024 * 1024 * 1024 : value * 1024 * 1024; return { value: value, unit: unit, display: `${value} ${unit}`, bytes: isNaN(bytes) ? 0 : bytes }; } } return { value: 0, unit: '', display: 'N/A', bytes: 0 }; }
function getMimeTypeFromUrl(url) { if (!url) return 'video/*'; const m = url.match(/\.([a-zA-Z0-9]+)(?:[?#]|$)/); if (!m) return 'video/*'; const ext = m[1].toLowerCase(); const mimeMap = { 'mkv': 'video/x-matroska', 'mp4': 'video/mp4', 'mov': 'video/quicktime', 'avi': 'video/x-msvideo', 'webm': 'video/webm', 'wmv': 'video/x-ms-wmv', 'flv': 'video/x-flv', 'ts': 'video/mp2t', 'm4v': 'video/x-m4v', 'ogv': 'video/ogg' }; return mimeMap[ext] || 'video/*'; }
function handleVideoError(event) { console.error("HTML5 Video Error:", event, videoElement?.error); let msg = "An unknown error occurred while trying to play the video."; if (videoElement?.error) { switch (videoElement.error.code) { case MediaError.MEDIA_ERR_ABORTED: msg = 'Playback was aborted.'; break; case MediaError.MEDIA_ERR_NETWORK: msg = 'A network error caused the video download to fail.'; break; case MediaError.MEDIA_ERR_DECODE: msg = 'Video decoding error (unsupported codec or corrupt file?).'; break; case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: msg = 'Video format not supported or server/network failed.'; break; default: msg = `An unknown video error occurred (Code: ${videoElement.error.code}).`; break; } } if (audioWarningDiv) { audioWarningDiv.innerHTML = `<strong>Playback Error:</strong> ${sanitize(msg)} <br>Consider using 'Copy URL' with an external player (VLC/MX) or 'Open Externally' (Android).`; audioWarningDiv.style.display = 'block'; } } if (videoElement) { videoElement.addEventListener('error', handleVideoError); }
function extractQualityFromFilename(filename) { if (!filename) return null; const patterns = [ /(?:^|\.|\[|\(|\s|_|-)((?:4k|2160p|1080p|720p|480p))(?=$|\.|\]|\)|\s|_|-)/i, /(?:^|\.|\[|\(|\s|_-)(WEB-?DL|WEBRip|BluRay|BDRip|BRRip|HDTV|HDRip|DVDrip|DVDScr|HDCAM|HC|TC|TS|CAM)(?=$|\.|\]|\)|\s|_|-)/i, /(?:^|\.|\[|\(|\s|_-)(HDR|DV|Dolby.?Vision|HEVC|x265)(?=$|\.|\]|\)|\s|_|-)/i ]; let foundQuality = null; for (const regex of patterns) { const match = filename.match(regex); if (match && match[1]) { let quality = match[1].toUpperCase(); quality = quality.replace(/WEB-?DL/i, 'WEBDL'); quality = quality.replace(/BLURAY/i, 'BluRay'); quality = quality.replace(/DVDRIP/i, 'DVD'); quality = quality.replace(/DOLBY.?VISION/i, 'Dolby Vision'); if (quality === '2160P') quality = '4K'; if (patterns.indexOf(regex) < 2) return quality; if (patterns.indexOf(regex) === 2 && !foundQuality) foundQuality = quality; } } return foundQuality; }
function normalizeTextForSearch(text) { if (!text) return ""; return String(text) .toLowerCase() .replace(/[.\-_\(\)\[\]]/g, '') .replace(/\s+/g, ' ') .trim(); }


// --- Data Preprocessing ---
/**
 * Preprocesses raw movie data fetched from the source.
 */
function preprocessMovieData(movie) {
    // ... (Keep this exactly the same as in your original code) ...
     const processed = {};
     processed.id = movie.id || null;
     processed.url = movie.url || null;
     processed.telegramLink = movie.telegramLink || null;
     processed.gdflixLink = movie.gdflixLink || null;
     processed.hubcloudLink = movie.hubcloudLink || null;
     processed.filepressLink = movie.filepressLink || null;
     processed.gdtotLink = movie.gdtotLink || null;
     processed.languages = movie.languages || null;
     processed.filenameSource = 'sheet';
     processed.displayFilename = sanitize(movie.filename || '');
     if (!processed.displayFilename && movie.url) { try { const urlObject = new URL(movie.url); let potentialFilename = ''; const pathParam = urlObject.searchParams.get('path'); if (pathParam) { const pathSegments = pathParam.split('/').filter(Boolean); if (pathSegments.length > 0) potentialFilename = decodeURIComponent(pathSegments[pathSegments.length - 1]); } if (!potentialFilename && urlObject.pathname && urlObject.pathname !== '/') { const pathSegments = urlObject.pathname.split('/').filter(Boolean); if (pathSegments.length > 0 && pathSegments[pathSegments.length - 1].includes('.')) { potentialFilename = decodeURIComponent(pathSegments[pathSegments.length - 1]); } } if (potentialFilename) { processed.displayFilename = sanitize(potentialFilename); processed.filenameSource = 'url'; } } catch (e) { console.warn("URL parsing failed for filename extraction:", movie.url, e); } } if (!processed.displayFilename) { processed.displayFilename = `File (ID: ${sanitize(processed.id || 'N/A')})`; processed.filenameSource = 'placeholder'; } if (processed.displayFilename !== sanitize(movie.filename || '')) { processed.originalFilename = movie.filename || null; } else { processed.originalFilename = null; }
     processed.sizeData = { display: 'N/A', bytes: 0 }; if (movie.size && String(movie.size).toLowerCase() !== 'n/a') { const explicitSize = extractSizeData(String(movie.size)); if (explicitSize && explicitSize.bytes > 0) processed.sizeData = explicitSize; } if (processed.sizeData.bytes === 0 && processed.filenameSource !== 'placeholder') { const extractedSize = extractSizeData(processed.displayFilename); if (extractedSize && extractedSize.bytes > 0) processed.sizeData = extractedSize; }
     processed.displayQuality = sanitize(movie.quality || 'N/A'); if ((!movie.quality || String(movie.quality).toLowerCase() === 'n/a') && processed.filenameSource !== 'placeholder') { const extractedQuality = extractQualityFromFilename(processed.displayFilename); if (extractedQuality) processed.displayQuality = sanitize(extractedQuality); } if (processed.displayQuality && processed.displayQuality !== 'N/A') { uniqueQualities.add(processed.displayQuality); }
     processed.lastUpdated = movie.lastUpdated || null; processed.lastUpdatedTimestamp = 0; if (processed.lastUpdated) { try { const parsedDate = new Date(processed.lastUpdated); if (!isNaN(parsedDate.getTime())) { processed.lastUpdatedTimestamp = parsedDate.getTime(); } else { console.warn("Invalid date format for lastUpdated:", processed.lastUpdated); } } catch (e) { console.warn("Error parsing lastUpdated date:", processed.lastUpdated, e); } }
     processed.numericId = Infinity; if (processed.id) { const parsedId = parseInt(String(processed.id).replace(/\D/g, ''), 10); if (!isNaN(parsedId)) processed.numericId = parsedId; }
     processed.searchText = normalizeTextForSearch(`${processed.id || ''} ${processed.displayFilename}`);
     const seriesRegex = /(?<![a-zA-Z])S(\d{1,3})(?:E\d{1,3}|[._\-\s])|\bSeason[._\-\s]?(\d{1,3})\b/i; processed.isSeries = seriesRegex.test(processed.displayFilename);
     return processed;
}

// --- HTML Generation ---
/**
 * Generates HTML for a movie row and its action row.
 * @param {object} movie - Processed movie data.
 * @param {number} index - Overall index (for unique IDs).
 * @param {string} context - View context ('upd', 'all', 'mov', 'ser', 'search').
 */
function createMovieRowsHTML(movie, index, context) {
    // ... (Keep this exactly the same as in your original code, just add 'search' to context) ...
     const uniqueIdPart = movie.id ? String(movie.id).replace(/[^a-zA-Z0-9-_]/g, '') : `gen-${index}`;
     const actionRowId = `${context}-actions-${uniqueIdPart}-${index}`; // Unique ID per context
     const displayFilename = movie.displayFilename; const displaySize = movie.sizeData.display; const displayQuality = movie.displayQuality;
     const streamTitle = displayFilename .split(/[\.\(\[]/)[0] .replace(/[_ ]+/g, ' ').trim() + (displayQuality !== 'N/A' ? ` (${displayQuality})` : '');
     const formattedDateRelative = TimeAgo.format(movie.lastUpdated); const formattedDateFull = movie.lastUpdatedTimestamp > 0 ? TimeAgo.formatFullDate(new Date(movie.lastUpdatedTimestamp)) : 'N/A';
     let hdrLogoHtml = ''; let fourkLogoHtml = ''; const lowerFilename = displayFilename.toLowerCase(); if (displayQuality === '4K' || lowerFilename.includes('2160p') || lowerFilename.includes('.4k.')) { fourkLogoHtml = `<img src="${config.FOURK_LOGO_URL}" alt="4K" class="quality-logo fourk-logo" title="4K Ultra HD" />`; } if (displayQuality.includes('HDR') || displayQuality.includes('DOLBY VISION') || displayQuality === 'DV' || lowerFilename.includes('hdr') || lowerFilename.includes('dolby.vision') || lowerFilename.includes('.dv.')) { hdrLogoHtml = `<img src="${config.HDR_LOGO_URL}" alt="HDR/DV" class="quality-logo hdr-logo" title="HDR / Dolby Vision Content" />`; }
     const escapedStreamTitle = streamTitle.replace(/'/g, "\\'"); const escapedFilename = displayFilename.replace(/'/g, "\\'"); const escapedUrl = movie.url ? movie.url.replace(/'/g, "\\'") : '';
     const colspanValue = 6;
     const mainRowHTML = ` <tr class="movie-data-row"> <td class="col-id">${sanitize(movie.id || 'N/A')}</td> <td class="col-filename" title="Click to view details: ${displayFilename}" onclick="toggleActions(this, '${actionRowId}')"> ${displayFilename}${fourkLogoHtml}${hdrLogoHtml} </td> <td class="col-size">${displaySize}</td> <td class="col-quality">${displayQuality}</td> <td class="col-updated" title="${formattedDateFull}">${formattedDateRelative}</td> <td class="col-view"><button class="button view-button" onclick="toggleActions(this, '${actionRowId}')">View</button></td> </tr> `;
     let actionButtonsHTML = ''; if (movie.url) { actionButtonsHTML += `<button class="button play-button" onclick="streamVideo('${escapedStreamTitle}', '${escapedUrl}', '${escapedFilename}')">Play here</button>`; actionButtonsHTML += `<a class="button download-button" href="${sanitize(movie.url)}" download="${displayFilename}" target="_blank" rel="noopener noreferrer">Direct Download</a>`; actionButtonsHTML += `<button class="button vlc-button" onclick="copyVLCLink(this, '${escapedUrl}')">Copy URL (for VLC/MX)</button>`; if (navigator.userAgent.toLowerCase().includes("android")) { actionButtonsHTML += `<button class="button intent-button" onclick="openWithIntent('${escapedUrl}')">Open Externally (Android)</button>`; } } if (movie.telegramLink) actionButtonsHTML += `<a class="button telegram-button" href="${sanitize(movie.telegramLink)}" target="_blank" rel="noopener noreferrer">Telegram File</a>`; if (movie.gdflixLink) { let gdflixButtonText = "GDFLIX"; if (movie.gdflixLink.includes('/pack/')) gdflixButtonText = "GDFLIX (pack)"; actionButtonsHTML += `<a class="button gdflix-button" href="${sanitize(movie.gdflixLink)}" target="_blank" rel="noopener noreferrer">${gdflixButtonText}</a>`; } if (movie.hubcloudLink) actionButtonsHTML += `<a class="button hubcloud-button" href="${sanitize(movie.hubcloudLink)}" target="_blank" rel="noopener noreferrer">HubCloud</a>`; if (movie.filepressLink) actionButtonsHTML += `<a class="button filepress-button" href="${sanitize(movie.filepressLink)}" target="_blank" rel="noopener noreferrer">Filepress</a>`; if (movie.gdtotLink) actionButtonsHTML += `<a class="button gdtot-button" href="${sanitize(movie.gdtotLink)}" target="_blank" rel="noopener noreferrer">GDToT</a>`; if (!actionButtonsHTML) { actionButtonsHTML = '<span style="color: var(--text-muted); font-style: italic; text-align: center; width: 100%; display: block; padding: 10px 0;">No stream/download actions available</span>'; }
     const actionRowHTML = ` <tr id="${actionRowId}" class="action-row" style="display: none;"> <td colspan="${colspanValue}"> <div class="action-info"> <span class="info-item"><strong>Filename:</strong> ${displayFilename}</span> <span class="info-item"><strong>Quality:</strong> ${displayQuality} ${fourkLogoHtml} ${hdrLogoHtml}</span> <span class="info-item"><strong>Size:</strong> ${displaySize}</span> <span class="info-item"><strong>Language:</strong> ${sanitize(movie.languages || 'N/A')}</span> <span class="info-item"><strong>Updated:</strong> ${formattedDateFull} (${formattedDateRelative})</span> ${movie.originalFilename ? `<span class="info-item"><strong>Original Name:</strong> ${sanitize(movie.originalFilename)}</span>` : ''} </div> <div class="action-buttons-container"> ${actionButtonsHTML} </div> </td> </tr>`;
    return mainRowHTML + actionRowHTML;
}


// --- Rendering Logic ---

/**
 * Applies current search, filter, and sort criteria. Does NOT render.
 * Updates the global `filteredAndSortedData`.
 */
function applyUserActions() {
    const normalizedSearch = normalizeTextForSearch(currentState.searchTerm);
    const searchKeywords = normalizedSearch ? normalizedSearch.split(' ').filter(Boolean) : [];

    // Filter the data
    filteredAndSortedData = allMovieData.filter(movie => {
        if (currentState.qualityFilter && movie.displayQuality !== currentState.qualityFilter) {
            return false;
        }
        if (isSearchActive && searchKeywords.length > 0 && !searchKeywords.every(keyword => movie.searchText.includes(keyword))) {
            return false; // Apply search filter only if search is active
        }
        // Assign exact match status only during active search
        movie.isExactMatch = isSearchActive && searchKeywords.length > 0 && movie.searchText.includes(normalizedSearch);
        return true;
    });

    // Sort the filtered data
    const sortKey = currentState.sortColumn;
    const direction = currentState.sortDirection === 'asc' ? 1 : -1;

    filteredAndSortedData.sort((a, b) => {
        // Prioritize exact matches if searching actively
        if (isSearchActive && searchKeywords.length > 0 && a.isExactMatch !== b.isExactMatch) {
            return a.isExactMatch ? -1 : 1;
        }

        let valA, valB;
        switch (sortKey) {
            case 'id': valA = a.numericId; valB = b.numericId; break;
            case 'filename': valA = a.displayFilename.toLowerCase(); valB = b.displayFilename.toLowerCase(); break;
            case 'size': valA = a.sizeData.bytes; valB = b.sizeData.bytes; break;
            case 'quality': valA = a.displayQuality.toLowerCase(); valB = b.displayQuality.toLowerCase(); break;
            case 'lastUpdated': default: valA = a.lastUpdatedTimestamp; valB = b.lastUpdatedTimestamp; break;
        }

        const aIsLess = (valA === null || typeof valA === 'undefined') || (valA < valB && valB !== null && typeof valB !== 'undefined');
        const bIsLess = (valB === null || typeof valB === 'undefined') || (valB < valA && valA !== null && typeof valA !== 'undefined');

        if (aIsLess) return -1 * direction;
        if (bIsLess) return 1 * direction;

        if (sortKey !== 'id' && sortKey !== 'lastUpdated') {
             if (b.lastUpdatedTimestamp !== a.lastUpdatedTimestamp) return b.lastUpdatedTimestamp - a.lastUpdatedTimestamp;
             if (b.numericId !== a.numericId) return b.numericId - a.numericId;
        }
        return 0;
    });

    // Don't reset pages here, let the calling function handle it
    saveStateToLocalStorage(); // Persist filter/sort state
}

/**
 * Renders the Search Results view.
 */
function renderSearchResults() {
    if (!searchResultsContainer || !searchResultsTableBody || !searchResultsPaginationControls) return;

    const totalItems = filteredAndSortedData.length;
    const totalPages = Math.ceil(totalItems / config.ITEMS_PER_PAGE);

    // Validate current page
    if (currentState.currentPage < 1) currentState.currentPage = 1;
    if (currentState.currentPage > totalPages && totalPages > 0) currentState.currentPage = totalPages;
    if (totalItems === 0) currentState.currentPage = 1;

    const startIndex = (currentState.currentPage - 1) * config.ITEMS_PER_PAGE;
    const endIndex = Math.min(startIndex + config.ITEMS_PER_PAGE, totalItems);
    const pageData = filteredAndSortedData.slice(startIndex, endIndex);

    let tableHtml = '';
    if (totalItems === 0) {
        tableHtml = `<tr><td colspan="6" class="status-message">No files found matching your criteria.</td></tr>`;
    } else {
        pageData.forEach((movie, index) => {
            tableHtml += createMovieRowsHTML(movie, startIndex + index, 'search'); // Use 'search' context
        });
    }
    searchResultsTableBody.innerHTML = tableHtml;

    renderPaginationControls(searchResultsPaginationControls, totalItems, currentState.currentPage);
    updateSortIndicators(searchResultsTableHead); // Update sort arrows for search table
    updateFilterIndicator();
}


/**
 * Renders the content for the currently active TAB.
 */
function renderActiveTabContent() {
    if (isSearchActive) return; // Don't render tabs if search is active

    // Ensure the correct tab is marked active visually
    Object.keys(tabMappings).forEach(tabId => {
        const mapping = tabMappings[tabId];
        if (mapping?.button) mapping.button.classList.toggle('active', tabId === currentActiveTab);
        if (mapping?.panel) mapping.panel.classList.toggle('active', tabId === currentActiveTab);
        if (mapping?.pagination) mapping.pagination.style.display = (tabId === currentActiveTab && mapping.pagination.innerHTML.trim() !== '') ? 'block' : 'none';
    });

    // 1. Render Updates (Always uses full, time-sorted original data, rendered if 'updates' tab is active)
    if (currentActiveTab === 'updates') {
        let updatesHtml = '';
        let updatesFound = false;
        let updateIndex = 0;
        const now = Date.now();
        const twentyFourHoursAgo = now - (24 * 60 * 60 * 1000);
        // Sort a *copy* of the original data just for updates view
        const sortedOriginalDataForUpdates = [...allMovieData].sort((a, b) => b.lastUpdatedTimestamp - a.lastUpdatedTimestamp);
        sortedOriginalDataForUpdates.forEach((movie) => {
            if (movie.lastUpdatedTimestamp >= twentyFourHoursAgo && movie.id && (movie.url || movie.telegramLink || movie.gdflixLink || movie.hubcloudLink || movie.filepressLink || movie.gdtotLink || movie.filenameSource !== 'placeholder') ) {
                updatesHtml += createMovieRowsHTML(movie, updateIndex, 'upd');
                updatesFound = true;
                updateIndex++;
            }
        });
        if (updatesTableBody) updatesTableBody.innerHTML = updatesFound ? updatesHtml : '<tr><td colspan="6" class="status-message">No updates in the last 24 hours.</td></tr>';
        // Hide pagination for updates tab
        if (tabMappings.updates.pagination) tabMappings.updates.pagination.style.display = 'none';
    }

    // 2. Render Filterable/Sortable Tabs (All, Movies, Series)
    // These use the `filteredAndSortedData` which respects quality filter and sort order
    const allFilesData = filteredAndSortedData;
    const moviesData = filteredAndSortedData.filter(movie => !movie.isSeries);
    const seriesData = filteredAndSortedData.filter(movie => movie.isSeries);

    // Render based on which tab is *actually* active
    switch (currentActiveTab) {
        case 'allFiles':
            renderPaginatedTable(allFilesData, allFilesTableBody, 'all', currentState.savedPageAll);
            renderPaginationControls(allFilesPaginationControls, allFilesData.length, currentState.savedPageAll);
            updateSortIndicators(allFilesTableHead);
            break;
        case 'movies':
             renderPaginatedTable(moviesData, moviesTableBody, 'mov', currentState.savedPageMovies);
             renderPaginationControls(moviesPaginationControls, moviesData.length, currentState.savedPageMovies);
             updateSortIndicators(moviesTableHead);
            break;
        case 'series':
             renderPaginatedTable(seriesData, seriesTableBody, 'ser', currentState.savedPageSeries);
             renderPaginationControls(seriesPaginationControls, seriesData.length, currentState.savedPageSeries);
             updateSortIndicators(seriesTableHead);
            break;
        // Updates tab handled above
    }

    updateFilterIndicator(); // Update filter style
    handleActiveActionRowState(); // Check if action row needs closing
}


/**
 * Helper function to render a paginated table (for TABS).
 * @param {Array} dataToRender - The (already filtered and sorted) data for this table.
 * @param {HTMLElement} tableBodyElement - The tbody element to populate.
 * @param {string} context - The context prefix for row IDs ('all', 'mov', 'ser').
 * @param {number} currentPageForTable - The specific page number for this table.
 */
function renderPaginatedTable(dataToRender, tableBodyElement, context, currentPageForTable) {
    if (!tableBodyElement) return;

    const totalItems = dataToRender.length;
    const totalPages = Math.ceil(totalItems / config.ITEMS_PER_PAGE);

    // Validate current page for *this specific dataset*
    if (currentPageForTable < 1) currentPageForTable = 1;
    if (currentPageForTable > totalPages && totalPages > 0) currentPageForTable = totalPages;
    if (totalItems === 0) currentPageForTable = 1;

    const startIndex = (currentPageForTable - 1) * config.ITEMS_PER_PAGE;
    const endIndex = Math.min(startIndex + config.ITEMS_PER_PAGE, totalItems);
    const pageData = dataToRender.slice(startIndex, endIndex);

    let tableHtml = '';
    if (totalItems === 0) {
        tableHtml = `<tr><td colspan="6" class="status-message">${currentState.qualityFilter ? 'No files found matching your criteria.' : 'No files in this category.'}</td></tr>`;
    } else {
        pageData.forEach((movie, index) => {
            tableHtml += createMovieRowsHTML(movie, startIndex + index, context);
        });
    }
    tableBodyElement.innerHTML = tableHtml;
}

/**
 * Renders pagination controls for a given container.
 * @param {HTMLElement} targetContainer - The pagination container element.
 * @param {number} totalItems - Total items in the dataset for this pagination.
 * @param {number} currentPage - The current active page number.
 */
function renderPaginationControls(targetContainer, totalItems, currentPage) {
    if (!targetContainer) return;

    const totalPages = Math.ceil(totalItems / config.ITEMS_PER_PAGE);

    // Validate current page again
    if (currentPage < 1) currentPage = 1;
    if (currentPage > totalPages && totalPages > 0) currentPage = totalPages;
    if (totalItems === 0) currentPage = 1;

    targetContainer.innerHTML = ''; // Clear existing controls
    if (totalPages <= 1) {
        targetContainer.style.display = 'none';
        return;
    }

    let paginationHTML = '';
    const maxPagesToShow = 5;
    const halfPages = Math.floor(maxPagesToShow / 2);

    // Previous Button
    paginationHTML += `<button onclick="changePage(${currentPage - 1})" ${currentPage === 1 ? 'disabled title="First page"' : 'title="Previous page"'}>« Prev</button>`;

    // Page Numbers
    if (totalPages <= maxPagesToShow + 2) {
        for (let i = 1; i <= totalPages; i++) {
            paginationHTML += (i === currentPage) ? `<span class="current-page">${i}</span>` : `<button onclick="changePage(${i})" title="Page ${i}">${i}</button>`;
        }
    } else {
        let startPage = Math.max(2, currentPage - halfPages);
        let endPage = Math.min(totalPages - 1, currentPage + halfPages);
        if (currentPage <= halfPages + 1) endPage = Math.min(totalPages - 1, maxPagesToShow);
        if (currentPage >= totalPages - halfPages) startPage = Math.max(2, totalPages - maxPagesToShow + 1);

        paginationHTML += (1 === currentPage) ? `<span class="current-page">1</span>` : `<button onclick="changePage(1)" title="Page 1">1</button>`;
        if (startPage > 2) paginationHTML += `<span class="page-info" title="Skipped pages">...</span>`;
        for (let i = startPage; i <= endPage; i++) {
            paginationHTML += (i === currentPage) ? `<span class="current-page">${i}</span>` : `<button onclick="changePage(${i})" title="Page ${i}">${i}</button>`;
        }
        if (endPage < totalPages - 1) paginationHTML += `<span class="page-info" title="Skipped pages">...</span>`;
        paginationHTML += (totalPages === currentPage) ? `<span class="current-page">${totalPages}</span>` : `<button onclick="changePage(${totalPages})" title="Page ${totalPages}">${totalPages}</button>`;
    }

    // Next Button
    paginationHTML += `<button onclick="changePage(${currentPage + 1})" ${currentPage === totalPages ? 'disabled title="Last page"' : 'title="Next page"'}>Next »</button>`;

    targetContainer.innerHTML = paginationHTML;
    targetContainer.style.display = 'block'; // Make sure it's visible
}

/**
 * Updates the visual indicators (arrows) on sortable table headers for the ACTIVE view.
 * @param {HTMLElement} tableHeadElement - The specific THEAD element to update.
 */
function updateSortIndicators(tableHeadElement) {
    if (!tableHeadElement) return;
    tableHeadElement.querySelectorAll('th.sortable').forEach(th => {
        th.classList.remove('sort-asc', 'sort-desc');
        if (th.dataset.sortKey === currentState.sortColumn) {
            th.classList.add(currentState.sortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
            th.setAttribute('aria-sort', currentState.sortDirection === 'asc' ? 'ascending' : 'descending');
        } else {
            th.removeAttribute('aria-sort');
        }
    });
}

/**
 * Updates the visual style of the quality filter select elements.
 */
function updateFilterIndicator() {
    if(qualityFilterSelect) {
        qualityFilterSelect.classList.toggle('filter-active', !!currentState.qualityFilter);
    }
}

/** Checks if the currently open action row is still valid/visible */
function handleActiveActionRowState() {
    if (activeActionRow && activeActionRow.style.display !== 'none') {
        const mainRow = activeActionRow.previousElementSibling;
        const isMainRowVisible = document.body.contains(mainRow); // Check if row exists
        let isParentVisible = false;

        if (isMainRowVisible) {
            const parentTable = mainRow.closest('table');
            if (parentTable) {
                if (isSearchActive && parentTable.id === 'searchResultsTable') {
                    isParentVisible = true;
                } else if (!isSearchActive) {
                    const parentTabPanel = parentTable.closest('.tab-content > div');
                    isParentVisible = parentTabPanel && parentTabPanel.classList.contains('active');
                }
            }
        }

        if (!isMainRowVisible || !isParentVisible) {
             closePlayer(); // Close player first
             activeActionRow.style.display = 'none'; // Then hide row
             activeActionRow = null; // Clear reference
        }
    } else if (activeActionRow && activeActionRow.style.display === 'none') {
         // Row was already hidden, just clear the reference if needed
         activeActionRow = null;
         // Don't necessarily close player here, let row logic handle it
    }
}


// --- Event Handlers ---

/**
 * Handles search input changes.
 */
function triggerSearch() {
    if (!searchInput) return;
    const newSearchTerm = searchInput.value.trim();

    if (newSearchTerm.length > 0 && !isSearchActive) {
        // --- Entering Search Mode ---
        isSearchActive = true;
        currentState.searchTerm = newSearchTerm;
        currentState.savedTabBeforeSearch = currentActiveTab; // Remember current tab
        currentState.currentPage = 1; // Reset page for search results
        closePlayerIfNeeded();
        if (tabNavigation) tabNavigation.style.display = 'none';
        if (tabContent) tabContent.style.display = 'none';
        if (searchResultsContainer) searchResultsContainer.style.display = 'block';
        applyUserActions(); // Filter and sort data
        renderSearchResults(); // Render the results view
        console.log("Entered Search Mode");

    } else if (newSearchTerm.length > 0 && isSearchActive) {
        // --- Updating Search Term within Search Mode ---
        if (newSearchTerm !== currentState.searchTerm) {
            currentState.searchTerm = newSearchTerm;
            currentState.currentPage = 1; // Reset page on term change
            closePlayerIfNeeded();
            applyUserActions();
            renderSearchResults();
             console.log("Updated Search Term");
        }
    } else if (newSearchTerm.length === 0 && isSearchActive) {
        // --- Exiting Search Mode ---
        isSearchActive = false;
        currentState.searchTerm = '';
        currentState.currentPage = 1; // Reset page state
        closePlayerIfNeeded();
        if (searchResultsContainer) searchResultsContainer.style.display = 'none';
        if (tabNavigation) tabNavigation.style.display = 'flex'; // Or 'block' depending on original style
        if (tabContent) tabContent.style.display = 'block';

        // Restore the previous tab
        currentActiveTab = currentState.savedTabBeforeSearch; // Set state variable
        applyUserActions(); // Re-apply filters/sorts without search term
        renderActiveTabContent(); // Re-render the restored tab view (will use currentActiveTab)
        console.log("Exited Search Mode, restored tab:", currentActiveTab);

    } else if (newSearchTerm.length === 0 && !isSearchActive) {
        // Search cleared, but wasn't in search mode (e.g., backspace on empty input)
        // Do nothing, or maybe re-apply filters if needed?
        if (currentState.searchTerm !== '') { // If state had term but input is now empty
            currentState.searchTerm = '';
            applyUserActions();
            renderActiveTabContent();
        }
    }
}


/**
 * Called when quality filter changes.
 */
function triggerFilterChange() {
     if (!qualityFilterSelect) return;
     const newQualityFilter = qualityFilterSelect.value;

     if (newQualityFilter !== currentState.qualityFilter) {
         currentState.qualityFilter = newQualityFilter;
         currentState.currentPage = 1; // Reset current view's page
         // Reset saved pages for tabs too, as filter affects them
         currentState.savedPageAll = 1;
         currentState.savedPageMovies = 1;
         currentState.savedPageSeries = 1;

         closePlayerIfNeeded();
         applyUserActions(); // Recalculate filteredAndSortedData

         // Render the currently visible view (search or tabs)
         if (isSearchActive) {
             renderSearchResults();
         } else {
             renderActiveTabContent();
         }
     }
 }

/**
 * Handles clicks on sortable table headers (works for tabs and search).
 */
function handleSort(event) {
    const header = event.target.closest('th.sortable');
    if (!header) return;
    const sortKey = header.dataset.sortKey;
    if (!sortKey) return;

    // Determine new sort state
    if (currentState.sortColumn === sortKey) {
        currentState.sortDirection = currentState.sortDirection === 'asc' ? 'desc' : 'asc';
    } else {
        currentState.sortColumn = sortKey;
        currentState.sortDirection = ['filename', 'quality'].includes(sortKey) ? 'asc' : 'desc';
    }

    currentState.currentPage = 1; // Reset current view's page to 1
    // Reset saved pages for tabs too, as sort affects them
    currentState.savedPageAll = 1;
    currentState.savedPageMovies = 1;
    currentState.savedPageSeries = 1;

    closePlayerIfNeeded();
    applyUserActions(); // Recalculate filteredAndSortedData

    // Render the currently visible view
    if (isSearchActive) {
        renderSearchResults();
    } else {
        renderActiveTabContent();
    }
}


/**
 * Changes the current page and re-renders the active view (search or tabs).
 */
function changePage(newPage) {
    let totalItems, totalPages;

    if (isSearchActive) {
        totalItems = filteredAndSortedData.length;
        totalPages = Math.ceil(totalItems / config.ITEMS_PER_PAGE);
        if (newPage >= 1 && newPage <= totalPages && newPage !== currentState.currentPage) {
            currentState.currentPage = newPage;
            closePlayerIfNeeded();
            renderSearchResults(); // Re-render search results with new page
            saveStateToLocalStorage();
            scrollToTopOfActiveTable(searchResultsTableBody);
        }
    } else {
        // Determine data set for the current tab
        let dataForPagination;
        let savedPageKey;
        const mapping = tabMappings[currentActiveTab];
        if (!mapping || !mapping.savedPageKey) return; // No pagination for this tab (e.g., Updates)

        savedPageKey = mapping.savedPageKey;
        switch (currentActiveTab) {
            case 'allFiles': dataForPagination = filteredAndSortedData; break;
            case 'movies': dataForPagination = filteredAndSortedData.filter(m => !m.isSeries); break;
            case 'series': dataForPagination = filteredAndSortedData.filter(m => m.isSeries); break;
            default: return;
        }

        totalItems = dataForPagination.length;
        totalPages = Math.ceil(totalItems / config.ITEMS_PER_PAGE);
        const currentSavedPage = currentState[savedPageKey];

        if (newPage >= 1 && newPage <= totalPages && newPage !== currentSavedPage) {
             currentState[savedPageKey] = newPage; // Update the specific saved page state
             closePlayerIfNeeded();
             renderActiveTabContent(); // Re-render the tab content (will use the new savedPageKey value)
             saveStateToLocalStorage();
             // Scroll to top of the active tab's table
             const activeTableBody = mapping.panel?.querySelector('tbody');
             scrollToTopOfActiveTable(activeTableBody);
        }
    }
}

/** Helper to scroll to the top of the active table */
function scrollToTopOfActiveTable(tableBodyElement) {
    if (tableBodyElement) {
        const tableContainer = tableBodyElement.closest('.table-container');
        const headerElement = tableContainer?.querySelector('thead');
        const headerHeight = headerElement ? headerElement.offsetHeight : 0;
        const scrollOffset = 20; // Adjust as needed
        const elementPosition = (tableContainer || tableBodyElement).getBoundingClientRect().top + window.pageYOffset;
        const offsetPosition = elementPosition - headerHeight - scrollOffset;

        window.scrollTo({ top: offsetPosition, behavior: 'smooth' });
    }
}

// --- Tab Switching Logic (Only works when not searching) ---
function switchTab(tabId) {
    if (isSearchActive || tabId === currentActiveTab) return; // Don't switch if searching or already on tab

    // Check if the requested tab exists in our mappings
    if (!tabMappings[tabId]) {
        console.error("Invalid tabId:", tabId);
        return;
    }

    currentActiveTab = tabId; // Update global tracker
    closePlayerIfNeeded();

    // applyUserActions(); // Re-apply filter/sort (might be needed if state changes affect tab visibility?)
    renderActiveTabContent(); // Renders the *newly set* currentActiveTab

    // Optional: Scroll to top when switching tabs
    if (videoContainer?.style.display !== 'flex') {
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
    saveStateToLocalStorage(); // Save the new active tab state indirectly
}


// --- Action Row / Player Logic ---
/**
 * Toggles the visibility of the action row. Works for tabs and search results.
 */
function toggleActions(clickedElement, targetRowId) {
     // ... (Keep this exactly the same as in your original code) ...
     const targetRow = document.getElementById(targetRowId); if (!targetRow) { console.error("Target action row not found:", targetRowId); return; } let mainRowElement = clickedElement.closest('tr'); if (!mainRowElement) { console.error("Could not find parent row."); return; } let buttonElement = mainRowElement.querySelector('.view-button'); if (!buttonElement) { console.error("Could not find view button."); return; } const isCurrentlyVisible = targetRow.style.display !== 'none';
     if (!isCurrentlyVisible && videoContainer?.style.display === 'flex' && activeActionRow !== targetRow) { closePlayer(); }
     if (activeActionRow && activeActionRow !== targetRow && activeActionRow.style.display !== 'none') { activeActionRow.style.display = 'none'; const otherMainRow = activeActionRow.previousElementSibling; const otherButton = otherMainRow?.querySelector('.view-button'); if (otherButton) { otherButton.textContent = 'View'; otherButton.setAttribute('aria-expanded', 'false'); } if (videoContainer?.parentElement === activeActionRow.querySelector('td')) { closePlayer(); } }
     if (isCurrentlyVisible) { targetRow.style.display = 'none'; buttonElement.textContent = 'View'; buttonElement.setAttribute('aria-expanded', 'false'); activeActionRow = null; closePlayer(); }
     else { targetRow.style.display = 'table-row'; buttonElement.textContent = 'Hide'; buttonElement.setAttribute('aria-expanded', 'true'); activeActionRow = targetRow; const actionCell = targetRow.querySelector('td'); if (actionCell && videoContainer?.parentElement !== actionCell) { if (videoElement && videoElement.hasAttribute('src')) { videoElement.pause(); videoElement.removeAttribute('src'); videoElement.load(); } if (videoContainer) videoContainer.style.display = 'none'; if (vlcBox) vlcBox.style.display = 'none'; if (audioWarningDiv) audioWarningDiv.style.display = 'none'; actionCell.appendChild(videoContainer); } else if (!actionCell) { console.error("Could not find action cell:", targetRowId); }
     setTimeout(() => { const headerElement = mainRowElement.closest('table')?.querySelector('thead'); const headerHeight = headerElement ? headerElement.offsetHeight : 0; const elementRect = mainRowElement.getBoundingClientRect(); const absoluteElementTop = elementRect.top + window.pageYOffset; const scrollOffset = 10; const offsetPosition = absoluteElementTop - headerHeight - scrollOffset; window.scrollTo({ top: offsetPosition, behavior: 'smooth' }); }, 100); }
}

/** Starts streaming video in the inline player. */
function streamVideo(title, url, filenameForAudioCheck) {
    // ... (Keep this exactly the same as in your original code) ...
    if (!videoContainer || !videoElement || !activeActionRow) { console.error("Cannot stream: player, video element, or active action row missing."); return; } const actionCell = activeActionRow.querySelector('td'); if (!actionCell) { console.error("Cannot stream: active action cell not found."); return; } if (videoContainer.parentElement !== actionCell) { console.warn("Video container not in expected cell. Moving."); if(videoElement && videoElement.hasAttribute('src')) { videoElement.pause(); videoElement.removeAttribute('src'); videoElement.load(); } if (vlcBox) vlcBox.style.display = 'none'; if (audioWarningDiv) audioWarningDiv.style.display = 'none'; actionCell.appendChild(videoContainer); }
    if (audioWarningDiv) { audioWarningDiv.style.display = 'none'; audioWarningDiv.innerHTML = ''; } if (audioTrackSelect) { audioTrackSelect.innerHTML = ''; audioTrackSelect.style.display = 'none'; } if (copyFeedbackSpan) copyFeedbackSpan.classList.remove('show');
    const savedVolume = localStorage.getItem(config.PLAYER_VOLUME_KEY); const savedSpeed = localStorage.getItem(config.PLAYER_SPEED_KEY); videoElement.volume = (savedVolume !== null) ? Math.max(0, Math.min(1, parseFloat(savedVolume))) : 1; if (volumeSlider) volumeSlider.value = videoElement.volume; videoElement.muted = (videoElement.volume === 0); videoElement.playbackRate = (savedSpeed !== null) ? parseFloat(savedSpeed) : 1; if(playbackSpeedSelect) playbackSpeedSelect.value = String(videoElement.playbackRate); updateMuteButton();
    const ddp51Regex = /\bDDP?([ ._-]?5\.1)?\b/i; const advancedAudioRegex = /\b(DTS|ATMOS|TrueHD)\b/i; const multiAudioHintRegex = /\b(Multi|Dual)[ ._-]?Audio\b/i; let warningText = ""; if (filenameForAudioCheck) { const lowerFilename = filenameForAudioCheck.toLowerCase(); if (ddp51Regex.test(lowerFilename)) { warningText = "<strong>Audio Note:</strong> DDP audio might not work in browser. Use 'Copy URL' or 'Open Externally'."; } else if (advancedAudioRegex.test(lowerFilename)) { warningText = "<strong>Audio Note:</strong> DTS/Atmos/TrueHD audio likely unsupported. Use external player."; } else if (multiAudioHintRegex.test(lowerFilename)) { warningText = "<strong>Audio Note:</strong> May contain multiple audio tracks. Use selector below or external player."; } } if (warningText && audioWarningDiv) { audioWarningDiv.innerHTML = warningText; audioWarningDiv.style.display = 'block'; }
    if (videoTitle) videoTitle.innerText = title; if (vlcText) vlcText.innerText = url; if (vlcBox) vlcBox.style.display = 'block'; videoElement.src = url; videoElement.load();
    videoElement.play().catch(e => { console.log("Autoplay prevented:", e.message); }); videoContainer.style.display = 'flex';
    setTimeout(() => { videoContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); }, 150);
}

/** Closes the inline video player. */
function closePlayer() {
    // ... (Keep this exactly the same as in your original code) ...
     if (!videoContainer || !videoElement) return; const wasPlaying = videoContainer.style.display !== 'none';
     try { const fsElement = document.fullscreenElement || document.webkitFullscreenElement; if (fsElement && (fsElement === videoElement || fsElement === videoContainer)) { if (document.exitFullscreen) document.exitFullscreen(); else if (document.webkitExitFullscreen) document.webkitExitFullscreen(); } } catch(err) { console.error("Error exiting fullscreen:", err); }
     videoElement.pause(); videoElement.removeAttribute('src'); videoElement.load();
     videoContainer.style.display = 'none'; if (vlcBox) vlcBox.style.display = 'none'; if (audioWarningDiv) { audioWarningDiv.style.display = 'none'; audioWarningDiv.innerHTML = ''; } if (audioTrackSelect) { audioTrackSelect.innerHTML = ''; audioTrackSelect.style.display = 'none'; } if (copyFeedbackSpan) copyFeedbackSpan.classList.remove('show'); if (videoTitle) videoTitle.innerText = '';
     // Move player back to main container only if it's not already there and main container exists
     if (container && document.body.contains(container) && videoContainer.parentElement !== container) {
         container.appendChild(videoContainer);
     } else if (!document.body.contains(container)) {
         console.warn("Main container not found, cannot move player back.");
     }
     // Remove 'Hide' text from button only if the row it belonged to is still marked as the active one
     if (wasPlaying && activeActionRow && activeActionRow.style.display === 'table-row') { // Check if row is still displayed
        const viewButton = activeActionRow.previousElementSibling?.querySelector('.view-button');
        if (viewButton && viewButton.textContent === 'Hide') {
            viewButton.textContent = 'View';
            viewButton.setAttribute('aria-expanded', 'false');
        }
     }
     if (videoContainer.classList.contains('is-fullscreen')) { videoContainer.classList.remove('is-fullscreen'); }
}

/** Utility to close player if visible */
function closePlayerIfNeeded() {
    if (videoContainer?.style.display === 'flex') { // Use 'flex' as the visible display style
         closePlayer();
    }
}

// --- Player Control Functions (seekVideo, togglePlayPause, toggleMute, updateMuteButton, setVolume, setPlaybackSpeed, toggleFullscreen, handleFullscreenChange, populateAudioTrackSelector, changeAudioTrack) ---
// ... (Keep these exactly the same as in your original code) ...
function seekVideo(seconds) { if (videoElement) videoElement.currentTime += seconds; } function togglePlayPause() { if (videoElement) { if (videoElement.paused || videoElement.ended) videoElement.play().catch(e => console.log("Play error:", e.message)); else videoElement.pause(); } } function toggleMute() { if (videoElement) videoElement.muted = !videoElement.muted; }
function updateMuteButton() { if (!videoElement || !muteButton) return; const isMuted = videoElement.muted || videoElement.volume === 0; muteButton.textContent = isMuted ? "Unmute" : "Mute"; muteButton.setAttribute('aria-pressed', String(isMuted)); if (volumeSlider) { volumeSlider.style.opacity = isMuted ? '0.5' : '1'; volumeSlider.disabled = isMuted; if (!isMuted && videoElement.volume === 0) { const defaultUnmuteVolume = 0.5; videoElement.volume = defaultUnmuteVolume; volumeSlider.value = defaultUnmuteVolume; } } }
function setVolume(value) { if (videoElement) { const vol = parseFloat(value); videoElement.volume = vol; videoElement.muted = (vol === 0); } } function setPlaybackSpeed(value) { if (videoElement) videoElement.playbackRate = parseFloat(value); }
function toggleFullscreen() { const elementToMakeFullscreen = videoContainer; if (!elementToMakeFullscreen) return; const fsElement = document.fullscreenElement || document.webkitFullscreenElement; try { if (!fsElement) { if (elementToMakeFullscreen.requestFullscreen) elementToMakeFullscreen.requestFullscreen(); else if (elementToMakeFullscreen.webkitRequestFullscreen) elementToMakeFullscreen.webkitRequestFullscreen(); } else { if (document.exitFullscreen) document.exitFullscreen(); else if (document.webkitExitFullscreen) document.webkitExitFullscreen(); } } catch (err) { console.error("Fullscreen API error:", err); alert("Fullscreen mode failed."); } }
function handleFullscreenChange() { const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement); if (!videoContainer) return; videoContainer.classList.toggle('is-fullscreen', isFullscreen); console.log("Fullscreen state changed:", isFullscreen); }
if(videoElement) { videoElement.addEventListener('volumechange', () => { if (volumeSlider && parseFloat(volumeSlider.value) !== videoElement.volume) volumeSlider.value = videoElement.volume; updateMuteButton(); try { localStorage.setItem(config.PLAYER_VOLUME_KEY, String(videoElement.volume)); } catch (e) { console.warn("LS volume save failed", e); } }); videoElement.addEventListener('ratechange', () => { if(playbackSpeedSelect) playbackSpeedSelect.value = String(videoElement.playbackRate); try { localStorage.setItem(config.PLAYER_SPEED_KEY, String(videoElement.playbackRate)); } catch (e) { console.warn("LS speed save failed", e); } }); videoElement.addEventListener('loadedmetadata', populateAudioTrackSelector); }
document.addEventListener('fullscreenchange', handleFullscreenChange); document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
function populateAudioTrackSelector() { if (!videoElement || typeof videoElement.audioTracks === 'undefined' || !audioTrackSelect) { if(audioTrackSelect) audioTrackSelect.style.display = 'none'; return; } const tracks = videoElement.audioTracks; audioTrackSelect.innerHTML = ''; if (tracks.length <= 1) { audioTrackSelect.style.display = 'none'; return; } let hasEnabledTrack = false; for (let i = 0; i < tracks.length; i++) { if (tracks[i].enabled) hasEnabledTrack = true; } if (!hasEnabledTrack && tracks.length > 0) { try { tracks[0].enabled = true; } catch(e) { console.warn("Could not auto-enable first audio track:", e); } } let preferredTrackIndex = -1; for (let i = 0; i < tracks.length; i++) { const track = tracks[i]; const option = document.createElement('option'); const trackValue = track.id || i; option.value = trackValue; let label = track.label || `Track ${i + 1}`; let languageName = ''; if (track.language) { try { languageName = new Intl.DisplayNames(['en'], { type: 'language' }).of(track.language.split('-')[0]); label += ` (${languageName || track.language})`; } catch (e) { label += ` (${track.language})`; } } option.textContent = label; option.selected = track.enabled; option.disabled = track.readyState === 'ended'; audioTrackSelect.appendChild(option); const lang = track.language?.toLowerCase(); const lbl = label.toLowerCase(); if (preferredTrackIndex === -1 && (lang?.startsWith('hi') || lbl.includes('hindi') || languageName?.toLowerCase() === 'hindi')) { preferredTrackIndex = i; } } if (preferredTrackIndex !== -1) { console.log(`Preferred track found at index ${preferredTrackIndex}. Attempting auto-selection.`); try { let trackChanged = false; for (let i = 0; i < tracks.length; i++) { const shouldBeEnabled = (i === preferredTrackIndex); if (tracks[i].enabled !== shouldBeEnabled) { tracks[i].enabled = shouldBeEnabled; trackChanged = true; } } const preferredTrackValue = tracks[preferredTrackIndex].id || preferredTrackIndex; audioTrackSelect.value = preferredTrackValue; if (trackChanged) console.log("Successfully auto-selected preferred track."); } catch(e) { console.error("Error auto-selecting preferred audio track:", e); } } else { console.log("No preferred audio track found."); for (let i = 0; i < tracks.length; i++) { if (tracks[i].enabled) { audioTrackSelect.value = tracks[i].id || i; break; } } } audioTrackSelect.style.display = 'inline-block'; try { if (tracks.onchange === null) tracks.onchange = populateAudioTrackSelector; } catch(e) { console.warn("Browser might not support 'onchange' on AudioTrackList", e)} }
function changeAudioTrack(selectElement) { if (!videoElement || !videoElement.audioTracks) return; const selectedTrackValue = selectElement.value; const tracks = videoElement.audioTracks; let trackChanged = false; for (let i = 0; i < tracks.length; i++) { const track = tracks[i]; const isSelectedTrack = (track.id && track.id === selectedTrackValue) || String(i) === selectedTrackValue; if (track.enabled !== isSelectedTrack) { try { track.enabled = isSelectedTrack; if (isSelectedTrack) console.log("Enabled audio track:", track.label || track.id || i); trackChanged = true; } catch (e) { console.error("Error changing audio track state for track:", track.id || i, e); } } } if (!trackChanged) console.warn("Selected audio track already active or no change applied."); }

// --- External Player / Copy Functionality (openWithIntent, copyVLCLink, fallbackCopyTextToClipboard, showCopyFeedback, highlightVlcText) ---
// ... (Keep these exactly the same as in your original code) ...
function openWithIntent(url) { if (!url) return; const mime = getMimeTypeFromUrl(url); const titleEncoded = encodeURIComponent(videoTitle?.innerText || document.title || 'Video'); const intentUri = `intent:${url}#Intent;type=${mime};action=android.intent.action.VIEW;S.title=${titleEncoded};end`; console.log("Intent:", intentUri); window.location.href = intentUri; } function copyVLCLink(buttonElement, url) { if (!url) return; const currentActionRow = buttonElement.closest('.action-row'); const currentVlcBox = currentActionRow?.querySelector('.vlc-copy-box'); const feedbackSpan = currentVlcBox?.querySelector('.copy-feedback'); if (!currentVlcBox || currentVlcBox.style.display === 'none') { console.warn("VLC box not visible/found for this row."); } if (navigator.clipboard && navigator.clipboard.writeText && window.isSecureContext) { navigator.clipboard.writeText(url).then(() => { if (feedbackSpan) showCopyFeedback(feedbackSpan); }).catch(err => { console.error("Async clipboard failed:", err); alert("Copy failed. Please copy manually."); highlightVlcText(); }); } else { console.warn("Using fallback copy."); fallbackCopyTextToClipboard(url, feedbackSpan); } } function fallbackCopyTextToClipboard(text, feedbackSpan) { const textArea = document.createElement("textarea"); textArea.value = text; textArea.style.position = "fixed"; textArea.style.top = "-9999px"; textArea.style.left = "-9999px"; textArea.style.opacity = "0"; textArea.setAttribute("readonly", ""); document.body.appendChild(textArea); let successful = false; try { textArea.select(); textArea.setSelectionRange(0, textArea.value.length); successful = document.execCommand('copy'); if (successful && feedbackSpan) showCopyFeedback(feedbackSpan); else if (!successful) throw new Error('execCommand failed'); } catch (err) { console.error('Fallback copy failed:', err); alert("Copy failed. Please copy manually."); highlightVlcText(); } finally { document.body.removeChild(textArea); } } function showCopyFeedback(spanElement) { if (!spanElement) return; clearTimeout(copyTimeout); spanElement.classList.add('show'); copyTimeout = setTimeout(() => { spanElement.classList.remove('show'); }, 2000); } function highlightVlcText() { const currentVlcBox = activeActionRow?.querySelector('.vlc-copy-box'); const currentVlcText = currentVlcBox?.querySelector('code'); if (currentVlcText && currentVlcBox?.style.display === 'block') { try { const range = document.createRange(); range.selectNodeContents(currentVlcText); const selection = window.getSelection(); if (selection) { selection.removeAllRanges(); selection.addRange(range); } } catch (selectErr) { console.warn("Could not highlight VLC text:", selectErr); } } }

// --- Player Keyboard Shortcuts ---
function handlePlayerKeyboardShortcuts(event) {
    // ... (Keep this exactly the same as in your original code) ...
     if (!videoContainer || videoContainer.style.display !== 'flex' || !videoElement) return; const targetTagName = event.target.tagName.toLowerCase(); if (targetTagName === 'input' || targetTagName === 'select' || targetTagName === 'textarea') return; const key = event.key; let prevented = false; switch (key) { case ' ': case 'k': togglePlayPause(); prevented = true; break; case 'ArrowLeft': seekVideo(-10); prevented = true; break; case 'ArrowRight': seekVideo(10); prevented = true; break; case 'ArrowUp': setVolume(Math.min(videoElement.volume + 0.05, 1)); prevented = true; break; case 'ArrowDown': setVolume(Math.max(videoElement.volume - 0.05, 0)); prevented = true; break; case 'm': toggleMute(); prevented = true; break; case 'f': toggleFullscreen(); prevented = true; break; } if (prevented) event.preventDefault();
}

// --- State Persistence ---
function saveStateToLocalStorage() {
    try {
        const stateToSave = {
            searchTerm: currentState.searchTerm,
            qualityFilter: currentState.qualityFilter,
            sortColumn: currentState.sortColumn,
            sortDirection: currentState.sortDirection,
            // No longer save generic currentPage
            savedPageAll: currentState.savedPageAll,
            savedPageMovies: currentState.savedPageMovies,
            savedPageSeries: currentState.savedPageSeries,
            savedTabBeforeSearch: currentState.savedTabBeforeSearch, // Save this too
             // Optionally save isSearchActive? Maybe not needed if searchTerm is saved.
        };
        localStorage.setItem(config.LOCAL_STORAGE_KEY, JSON.stringify(stateToSave));
    }
    catch (e) { console.error("Failed to save state to localStorage:", e); }
}

function loadStateFromLocalStorage() {
    try {
        const savedState = localStorage.getItem(config.LOCAL_STORAGE_KEY);
        if (savedState) {
            const parsedState = JSON.parse(savedState);
            currentState.searchTerm = typeof parsedState.searchTerm === 'string' ? parsedState.searchTerm : '';
            currentState.qualityFilter = typeof parsedState.qualityFilter === 'string' ? parsedState.qualityFilter : '';
            currentState.sortColumn = typeof parsedState.sortColumn === 'string' ? parsedState.sortColumn : 'lastUpdated';
            currentState.sortDirection = (typeof parsedState.sortDirection === 'string' && ['asc', 'desc'].includes(parsedState.sortDirection)) ? parsedState.sortDirection : 'desc';
            currentState.savedPageAll = (typeof parsedState.savedPageAll === 'number' && parsedState.savedPageAll > 0) ? Math.floor(parsedState.savedPageAll) : 1;
            currentState.savedPageMovies = (typeof parsedState.savedPageMovies === 'number' && parsedState.savedPageMovies > 0) ? Math.floor(parsedState.savedPageMovies) : 1;
            currentState.savedPageSeries = (typeof parsedState.savedPageSeries === 'number' && parsedState.savedPageSeries > 0) ? Math.floor(parsedState.savedPageSeries) : 1;
            currentState.savedTabBeforeSearch = typeof parsedState.savedTabBeforeSearch === 'string' ? parsedState.savedTabBeforeSearch : 'updates';

            // Determine initial view based on loaded search term
            isSearchActive = currentState.searchTerm.length > 0;
            currentState.currentPage = 1; // Always start on page 1 on load

            if(searchInput) searchInput.value = currentState.searchTerm;
            // Set the current active tab based on saved state, IF NOT searching
            if (!isSearchActive) {
                currentActiveTab = currentState.savedTabBeforeSearch || 'updates';
            }

        } else {
             // Set default if no saved state
             isSearchActive = false;
             currentState.searchTerm = '';
             currentState.currentPage = 1;
             currentActiveTab = 'updates'; // Default tab
        }
    } catch (e) {
        console.error("Failed to load state from localStorage:", e);
        localStorage.removeItem(config.LOCAL_STORAGE_KEY); // Clear corrupted state
        // Reset to defaults
        isSearchActive = false;
        currentState.searchTerm = '';
        currentState.currentPage = 1;
        currentActiveTab = 'updates'; // Default tab
    }
}

// --- Initial Data Loading and Setup ---
async function loadInitialData() {
    const loadingHTML = '<tr><td colspan="6" class="status-message">Loading... <div class="spinner" style="margin: 10px auto;"></div></td></tr>';
    // Show loading in all potential table bodies
    Object.values(tabMappings).forEach(mapping => {
        if(mapping?.panel) {
            const tbody = mapping.panel.querySelector('tbody');
            if (tbody) tbody.innerHTML = loadingHTML;
        }
    });
    if(searchResultsTableBody) searchResultsTableBody.innerHTML = loadingHTML;

    // Hide all pagination controls initially
    Object.values(tabMappings).forEach(mapping => {
        if(mapping?.pagination) mapping.pagination.style.display = 'none';
    });
    if(searchResultsPaginationControls) searchResultsPaginationControls.style.display = 'none';

    // Hide search results container initially
    if(searchResultsContainer) searchResultsContainer.style.display = 'none';

    uniqueQualities.clear();
    loadStateFromLocalStorage(); // Load state, sets isSearchActive and currentActiveTab (if not searching)

    try {
        if (!config.GSheetWebAppURL || config.GSheetWebAppURL.includes("macros/library/d/")) {
            throw new Error("Google Sheet Web App URL is missing or incorrect. Please paste your deployed script URL into the 'config' object.");
        }
        console.log("Fetching data from:", config.GSheetWebAppURL);
        const response = await fetch(config.GSheetWebAppURL);
        if (!response.ok) {
             let errorText = `Network error: ${response.statusText || `HTTP status ${response.status}`}`;
             try { const errorData = await response.json(); if(errorData?.error) errorText = `API Error: ${errorData.error}`; } catch(e) { /* Ignore */ }
             throw new Error(errorText);
        }
        const result = await response.json();
        if (result.error) throw new Error(`API Error: ${result.error}`);
        if (!Array.isArray(result.data)) throw new Error("Invalid data format (expected 'data' array).");

        allMovieData = result.data
                        .filter(movie => movie && (movie.id || movie.filename || movie.url))
                        .map(preprocessMovieData);
        console.log(`Processed ${allMovieData.length} items.`);

        populateQualityFilter(); // Populate the filter dropdown

        // Restore selected quality filter *after* options are populated
        if(qualityFilterSelect && uniqueQualities.has(currentState.qualityFilter)) {
             qualityFilterSelect.value = currentState.qualityFilter;
        } else if (qualityFilterSelect) {
             qualityFilterSelect.value = '';
             if (!uniqueQualities.has(currentState.qualityFilter)) {
                  currentState.qualityFilter = ''; // Ensure state matches empty selection
             }
        }
        updateFilterIndicator();

        // Apply initial filters/sort based on loaded state
        applyUserActions();

        // ----- *** REVISED INITIAL RENDER LOGIC *** -----
        if (isSearchActive) {
            console.log("Loading directly into Search Mode.");
            if (tabNavigation) tabNavigation.style.display = 'none';
            if (tabContent) tabContent.style.display = 'none';
            if (searchResultsContainer) searchResultsContainer.style.display = 'block';
            renderSearchResults(); // Render search results directly
        } else {
            console.log("Loading into Tab Mode, initial tab:", currentActiveTab);
            if (tabNavigation) tabNavigation.style.display = 'flex'; // Or block
            if (tabContent) tabContent.style.display = 'block';
            if (searchResultsContainer) searchResultsContainer.style.display = 'none';

            // No need to call switchTab here. currentActiveTab is already set.
            // Just call the main tab rendering function.
            renderActiveTabContent();
        }
        // ----- *** END REVISED LOGIC *** -----


    } catch (error) {
        console.error('FATAL: Failed to load/process initial data:', error);
        const errorMessage = `Error loading data: ${error.message}. Check script URL, sheet config, and deployment. Refresh page.`;
        displayLoadError(errorMessage);
    }
}


/** Populates the quality filter dropdown. */
function populateQualityFilter() {
    // ... (Keep this exactly the same as in your original code) ...
     if (!qualityFilterSelect) return; const currentSelectedValue = currentState.qualityFilter; const sortedQualities = [...uniqueQualities].sort((a, b) => { const resRegex = /^(4K|\d{3,4})P$/i; const sourceRegex = /^(WEBDL|WEBRip|BluRay|BDRip|BRRip|HDTV|HDRip|DVD|DVDScr|HDCAM|HC|TC|TS|CAM)$/i; const getScore = (q) => { q = String(q || '').toUpperCase(); if (q === '4K' || q === '2160P') return 10; if (q === '1080P') return 9; if (q === '720P') return 8; if (q === '480P') return 7; if (sourceRegex.test(q)) return 6; if (['HDR', 'DOLBY VISION', 'DV', 'HEVC', 'X265'].includes(q)) return 5; return 0; }; const scoreA = getScore(a); const scoreB = getScore(b); if (scoreA !== scoreB) return scoreB - scoreA; return String(a || '').localeCompare(String(b || ''), undefined, { sensitivity: 'base' }); });
     qualityFilterSelect.innerHTML = '<option value="">All Qualities</option>'; sortedQualities.forEach(quality => { if (quality) { const option = document.createElement('option'); option.value = quality; option.textContent = quality; qualityFilterSelect.appendChild(option); } });
     // Ensure the select value matches the state *after* populating
     qualityFilterSelect.value = currentState.qualityFilter || "";
}

/** Displays a critical error message in the appropriate visible table body. */
function displayLoadError(message) {
    const errorMsgHTML = `<tr><td colspan="6" class="error-message">${sanitize(message)}</td></tr>`;
    // Determine where to show the error based on initial load state attempt
    if (isSearchActive && searchResultsTableBody) {
        searchResultsTableBody.innerHTML = errorMsgHTML;
        if (searchResultsContainer) searchResultsContainer.style.display = 'block';
        if (tabNavigation) tabNavigation.style.display = 'none';
        if (tabContent) tabContent.style.display = 'none';
    } else if (updatesTableBody) { // Use updates as default tab target for errors if not searching
        updatesTableBody.innerHTML = errorMsgHTML;
        if (searchResultsContainer) searchResultsContainer.style.display = 'none';
        if (tabNavigation) tabNavigation.style.display = 'flex'; // Or block
        if (tabContent) tabContent.style.display = 'block';
        // Make sure the updates tab is visually active
        Object.keys(tabMappings).forEach(tabId => {
            const mapping = tabMappings[tabId];
             if (mapping?.button) mapping.button.classList.toggle('active', tabId === 'updates');
             if (mapping?.panel) mapping.panel.classList.toggle('active', tabId === 'updates');
        });
        currentActiveTab = 'updates'; // Ensure state matches
    } else {
        // Fallback if no bodies found
        if(container) container.innerHTML = `<div class="error-message" style="padding: 20px;">${sanitize(message)}</div>`;
    }
    // Hide all pagination controls on error
    Object.values(tabMappings).forEach(mapping => {
        if(mapping?.pagination) mapping.pagination.style.display = 'none';
    });
    if(searchResultsPaginationControls) searchResultsPaginationControls.style.display = 'none';
}

// --- Global Event Listeners Setup ---
document.addEventListener('DOMContentLoaded', () => {
    loadInitialData(); // Fetch data and set up initial view

    // --- Search Input Handling ---
    if (searchInput) {
        searchInput.addEventListener('input', () => {
            clearTimeout(searchDebounceTimeout);
            searchDebounceTimeout = setTimeout(triggerSearch, config.SEARCH_DEBOUNCE_DELAY);
        });
        searchInput.addEventListener('keydown', (event) => {
             if (event.key === 'Enter') {
                 event.preventDefault();
                 clearTimeout(searchDebounceTimeout);
                 triggerSearch();
             }
         });
        searchInput.addEventListener('search', () => { // Handles 'x' button click
            clearTimeout(searchDebounceTimeout);
            // Value clears slightly after event, use timeout
            setTimeout(() => { if (searchInput.value === '') triggerSearch(); }, 50); // Small delay
        });
    }

    // --- Quality Filter Handling ---
    if (qualityFilterSelect) {
        qualityFilterSelect.addEventListener('change', triggerFilterChange);
    }

    // --- Table Sorting Handling (Add listeners to all sortable tables) ---
    [allFilesTableHead, moviesTableHead, seriesTableHead, searchResultsTableHead].forEach(head => {
        if(head) head.addEventListener('click', handleSort);
    });

    // --- Player Keyboard Shortcuts ---
    document.addEventListener('keydown', handlePlayerKeyboardShortcuts);

    // Tab switching listeners are set via onclick attributes in HTML
    // They will implicitly not work if .tab-navigation is hidden
});

// ]]>
</script>
</body>
</html>
